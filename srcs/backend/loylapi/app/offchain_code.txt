
=== tasks/onchain.py ===
from __future__ import annotations
import asyncio, base58
from typing import cast
from sqlalchemy.future import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.celery_app import celery
from app.db.session import AsyncSessionLocal
from app.models import SwapTx, TxStatus, Wallet, Token
from app.services.transfer_exec import redeem_token, earn_token
from app.services.pubsub import publish
from app.core.settings import settings
from app.services.celery_wrapper import log_task
from logging import getLogger

logger = getLogger(__name__)


@celery.task(name="onchain.swap", bind=True, max_retries=3)
@log_task
def swap_task(self, swap_tx_id: str) -> None:
    """
    Celery task: perform a two-step on-chain swap of Token A → LOYL → Token B.

    1) User transfers 'from_amount' of Token A to platform (redeem_transfer).
    2) Platform transfers 'to_amount' of Token B to user     (earn_transfer).
    3) Persist the final Solana signature on SwapTx.sol_sig.

    Retries up to 3 times on failure, with 10s backoff.
    """

    async def _run_swap() -> None:
        await publish(f"swap:{swap_tx_id}",
                      {"swap_id": swap_tx_id, "event": "pending"})
        async with AsyncSessionLocal() as session:  # type: AsyncSession
            # 1) Load SwapTx
            swap = await session.get(SwapTx, swap_tx_id)
            if swap is None:
                raise ValueError(f"SwapTx {swap_tx_id} not found")
            if swap.sol_sig is not None:
                logger.warning(f"Swap {swap_tx_id} already processed")
                return

            # 2) Validate amounts and cast to int
            from_amt = cast(int, swap.from_amount)
            to_amt = cast(int, swap.to_amount)
            if from_amt <= 0 or to_amt <= 0:
                raise ValueError(f"Invalid swap amounts: {from_amt}, {to_amt}")
            logger.info(f"Processing swap {swap_tx_id}: {from_amt}→{to_amt}")

            # 3) Fetch user wallet
            q = await session.execute(
                select(Wallet).where(Wallet.user_id == swap.user_id)
            )
            wallet = q.scalar_one_or_none()
            if wallet is None:
                raise ValueError(f"Wallet for user {swap.user_id} not found")
            logger.info(f"User wallet: {wallet.pubkey}")

            # 4) Load token records
            from_token = await session.get(Token, swap.from_token_id)
            to_token = await session.get(Token, swap.to_token_id)
            if from_token is None or to_token is None:
                raise ValueError("Token(s) for swap not found")

            # 5) Step 1: user → platform for Token A
            platform_pubkey = str(settings.treasury_kp.pubkey())
            sig_redeem = redeem_token(
                mint=str(from_token.mint),
                user_pubkey=wallet.pubkey,
                business_pubkey=platform_pubkey,
                amount=from_amt,
            )
            logger.info(f"Redeem signature: {sig_redeem}")

            # 6) Step 2: platform → user for Token B
            treasury_bytes = settings.treasury_kp.to_bytes()
            treasury_b58 = base58.b58encode(treasury_bytes).decode("utf-8")
            sig_earn = earn_token(
                mint=str(to_token.mint),
                user_pubkey=wallet.pubkey,
                business_kp_b58=treasury_b58,
                amount=to_amt,
            )
            logger.info(f"Earn signature: {sig_earn}")

            # 7) Persist signatures and status
            swap.sol_sig = sig_earn
            swap.sol_sig_redeem = sig_redeem
            swap.status = TxStatus.SUCCESS
            await session.commit()

            await publish(f"swap:{swap_tx_id}",
                          {"swap_id": swap_tx_id, "event": "success"})


    try:
        asyncio.run(_run_swap())
    except Exception as exc:
        logger.error(f"Swap {swap_tx_id} failed: {exc}", exc_info=True)
        asyncio.run(publish(f"swap:{swap_tx_id}",
                            {"swap_id": swap_tx_id, "event": "failed"}))
        raise self.retry(exc=exc, countdown=10, queue="onchain")

=== tasks/__init__.py ===
from . import onchain  # noqa: F401
from . import business  # noqa: F401
from . import confirm  # noqa: F401
=== tasks/transfer.py ===
from app.celery_app import celery
from app.services.transfer_exec import earn_token, redeem_token
from app.services.celery_wrapper import log_task


@celery.task(name="onchain.transfer_earn", queue="onchain", bind=True, max_retries=3)
@log_task
def transfer_earn_task(
    self, *, business_kp_b58: str, mint: str, user_pubkey: str, amount: int
):
    """
    Celery wrapper for business → user transfer.
    """
    try:
        earn_token(business_kp_b58, mint, user_pubkey, amount)
    except Exception as exc:
        raise self.retry(exc=exc, countdown=10)


@celery.task(name="onchain.transfer_redeem", queue="onchain", bind=True, max_retries=3)
@log_task
def transfer_redeem_task(
    self, *, user_pubkey: str, mint: str, business_pubkey: str, amount: int
):
    """
    Celery wrapper for user → business transfer.
    """
    try:
        redeem_token(user_pubkey, mint, business_pubkey, amount)
    except Exception as exc:
        raise self.retry(exc=exc, countdown=10)

=== tasks/business.py ===
from app.celery_app import celery
from app.services.token_mint import mint_and_record  # need to implement
from app.services.celery_wrapper import log_task


@celery.task(name="onchain.mint_token", queue="onchain")
@log_task
def mint_token_task(business_id: str):
    """Mint SPL-2022 token & init pool."""
    mint_and_record(business_id)

=== tasks/voucher.py ===
from app.celery_app import celery
from app.services.bubblegum import bubblegum_minter
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker
from app.core.settings import settings
from app.models import VoucherTemplate
from uuid import UUID
from app.services.celery_wrapper import log_task

engine = create_async_engine(settings.database_url, future=True, echo=False)
Session = async_sessionmaker(engine, expire_on_commit=False)

@celery.task(name="onchain.mint_voucher", queue="onchain")
@log_task
def mint_voucher_task(template_id: str, user_id: str):
    async def _go():
        async with Session() as db:
            tmpl = await db.get(VoucherTemplate, UUID(template_id))
            if tmpl:
                await bubblegum_minter.mint(db, tmpl, UUID(user_id))
    import asyncio; asyncio.run(_go())

=== tasks/confirm.py ===
"""Periodic confirmation of outbound Solana transactions."""
from __future__ import annotations
import asyncio, logging
from typing import List
from celery import Celery
from solana.rpc.async_api import AsyncClient
from sqlalchemy import select
from app.core.settings import settings
from app.db.session import AsyncSessionLocal
from app.models import CeleryTaskLog, TaskStatus
from app.celery_app import celery
from app.services.celery_wrapper import log_task

log = logging.getLogger(__name__)
celery: Celery  # autodiscovered by Celery


def _confirm_all() -> None:
    """Async helper: poll pending tasks and update statuses."""
    async def _run():
        async with AsyncSessionLocal() as db, AsyncClient(settings.SOLANA_RPC_URL) as rpc:
            # 1) We collect all PENDING logs with real results.
            stmt = select(CeleryTaskLog).where(
                CeleryTaskLog.status == TaskStatus.PENDING,
                CeleryTaskLog.result.is_not(None),
            )
            pending = (await db.execute(stmt)).scalars().all()
            if not pending:
                return

            # 2) We take a list of caption strings
            sigs: List[str] = [log_entry.result for log_entry in pending if log_entry.result]

            # 3) We request the statuses.
            res = await rpc.get_signature_statuses(sigs)
            statuses = res.value

            # 4) Updating records
            for entry, status in zip(pending, statuses, strict=True):
                if status and status.confirmations is not None and status.err is None:
                    entry.status = TaskStatus.SUCCESS
                elif status and status.err is not None:
                    entry.status = TaskStatus.FAILED

            await db.commit()

    asyncio.run(_run())


@celery.task(
    name="onchain.confirm_tx",
    queue="onchain",
    bind=True,
    max_retries=None,
)
@log_task
def confirm_tx(self) -> None:
    """
    Celery task: runs every 30s via beat_schedule.
    Calls Solana RPC get_signature_statuses on all pending txs,
    marks SUCCESS or FAILED in CeleryTaskLog.
    """
    try:
        _confirm_all()
    except Exception as exc:
        log.error("confirm_tx failed: %s", exc, exc_info=True)
        # We don't retract — the next launch after beat will retry.

=== core/security.py ===
import functools, httpx, time
from jose import jwt
from jose.utils import base64url_decode
from typing import List, Dict
from pydantic import BaseModel
from app.core.settings import settings

PRIVY_JWKS = "https://auth.privy.io/.well-known/jwks.json"
ALGS = ["ES256"]
_JWKS_CACHE: tuple[float, List[Dict]] = (0.0, [])


@functools.lru_cache(maxsize=1)
def _jwks() -> List[Dict]:
    """
    Fetch JWKS with 10-minute TTL cache.
    """
    global _JWKS_CACHE
    now = time.time()
    ts, keys = _JWKS_CACHE
    if now - ts < 600 and keys:
        return keys

    r = httpx.get(PRIVY_JWKS, timeout=10)
    r.raise_for_status()
    data = r.json()
    # garantee that keys will be list[dict]
    new_keys = data.get("keys") or []
    if not isinstance(new_keys, list):
        new_keys = []
    # cache update

    _JWKS_CACHE = (now, new_keys)
    return new_keys


class TokenClaims(BaseModel):
    did: str
    sid: str


# kid-aware JWKS validation; prevents key-mix-attacks


def _get_signing_key(token: str) -> dict:
    headers = jwt.get_unverified_header(token)
    kid = headers["kid"]
    for key in _jwks():
        if key.get("kid") == kid:
            return key
    raise ValueError("No matching JWK")


def verify_privy_token(token: str) -> TokenClaims:
    key = _get_signing_key(token)
    payload = jwt.decode(
        token,
        key,
        algorithms=ALGS,
        audience=settings.PRIVY_APP_ID,
        issuer="https://auth.privy.io",
    )
    return TokenClaims(did=payload["sub"], sid=payload["sid"])

=== core/__init__.py ===

=== core/settings.py ===
import json
from pathlib import Path
from functools import lru_cache
from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict
from typing import Any, Dict
from solders.keypair import Keypair
from solders.pubkey import Pubkey


class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=str(
            Path(__file__).resolve().parent.parent.parent.parent.parent.parent / ".env"
        ),
        env_file_encoding="utf-8",
        env_prefix="",
        extra="ignore",
    )

    ROOT: Path = Path(__file__).resolve().parent.parent.parent
    print(f"============= {ROOT} =============")
    ENV: str = Field("dev")
    SQLITE_PATH: str = Field(default="sqlite+aiosqlite:///./dev.db")

    DB_HOST: str | None = Field(default=None)
    DB_PORT: int | None = Field(default=None)
    POSTGRES_DB: str | None = Field(default=None)
    POSTGRES_USER: str | None = Field(default=None)
    POSTGRES_PASSWORD: str | None = Field(default=None)

    TREASURY_KEYPAIR: str = Field(...)
    SOLANA_RPC_URL: str = Field("https://api.test.solana.com")
    EXCHANGE_PROGRAM_ID: str = Field(...)
    EXCHANGE_IDL_PATH: str = Field("/app/anchor/target/idl/exchange.json")
    LOYL_TOKEN_PROGRAM_ID: str = Field(...)
    LOYL_IDL_PATH: str = Field("/app/anchor/target/idl/loyl_token.json")
    LOYL_SETTLEMENT_PROGRAM_ID: str = Field(...)
    LOYL_SETTLEMENT_IDL_PATH: str = Field("/app/anchor/target/idl/loyl_settlement.json")

    PRIVY_APP_ID: str = Field(...)
    PRIVY_API_KEY: str = Field(...)
    PRIVY_API_SECRET: str = Field(...)

    CELERY_BROKER: str = Field(...)
    CELERY_BACKEND: str = Field(...)

    @property
    def root(self) -> Path:
        return self.ROOT

    @property
    def database_url(self) -> str:
        if self.ENV == "dev":
            return self.SQLITE_PATH
        return (
            f"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}"
            f"@{self.DB_HOST}:{self.DB_PORT}/{self.POSTGRES_DB}"
        )

    @property
    def fastapi_kwargs(self) -> Dict[str, Any]:
        if self.ENV == "prod":
            return {
                "docs_url": None,
                "redoc_url": None,
                "openapi_url": None,
            }
        return {}

    @property
    def treasury_kp(self) -> Keypair:
        """ """
        raw = self.TREASURY_KEYPAIR  # string like "[12,34,...]"
        nums = json.loads(raw)  # list[int]
        return Keypair.from_bytes(bytes(nums))

    @property
    def exchange_program_pk(self) -> Pubkey:
        """
        Pubkey of exchange program, getting from EXCHANGE_PROGRAM_ID.
        """
        return Pubkey.from_string(self.EXCHANGE_PROGRAM_ID)


@lru_cache
def get_settings() -> Settings:
    return Settings()


settings = get_settings()

=== celery_app.py ===
from celery import Celery
from app.core.settings import settings

celery = Celery(
    "loyelto",
    broker=settings.CELERY_BROKER,
    backend=settings.CELERY_BACKEND,
)
# for all onchain.* goes to "onchain"
celery.conf.task_routes = {"onchain.*": {"queue": "onchain"}}
celery.autodiscover_tasks(["app.tasks"])

celery.conf.beat_schedule = {
    "confirm-solana-txs": {
        "task": "onchain.confirm_tx",
        "schedule": 30.0,  # every 30 secs
        "options": {"queue": "onchain"},
    }
}
celery.conf.update(
    task_acks_late=True,
    worker_prefetch_multiplier=1,
    task_acks_on_failure_or_timeout=True,
    task_default_rate_limit="20/s",
)
=== __init__.py ===

=== models/token_pool.py ===
from __future__ import annotations
import uuid
from app.db.base import Base
from app.models import Token

from app.utils import uuid_pk
from sqlalchemy import (
    CheckConstraint,
    UniqueConstraint,
    ForeignKey,
    String,
    BigInteger,
)
from sqlalchemy.orm import (
    Mapped,
    mapped_column,
    relationship,
)


class TokenPool(Base):
    __tablename__ = "token_pools"
    __table_args__ = (
        UniqueConstraint("token_id", name="uq_token_pool"),
        CheckConstraint(
            "balance_token >= 0 AND balance_loyl >= 0", name="check_pool_nonnegative"
        ),
    )

    id: Mapped[uuid.UUID] = uuid_pk()
    token_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("tokens.id", ondelete="CASCADE")
    )
    provider: Mapped[str] = mapped_column(
        String(16),
        default="platform",
    )
    init_tx: Mapped[str] = mapped_column(
        String(88),  # len for Solana tx signature
        nullable=False,
        comment="Signature of the on-chain tx that initialized this pool",
    )

    balance_token: Mapped[int] = mapped_column(BigInteger)
    balance_loyl: Mapped[int] = mapped_column(BigInteger)

    token: Mapped["Token"] = relationship(lazy="noload")

=== models/user.py ===
from __future__ import annotations
import uuid
import datetime
from app.utils import uuid_pk
from app.db.base import Base
from sqlalchemy.sql import func
from sqlalchemy import (
    String,
    DateTime,
)
from sqlalchemy.orm import (
    Mapped,
    mapped_column,
    relationship,
)


class User(Base):
    __tablename__ = "users"

    id: Mapped[uuid.UUID] = uuid_pk()
    privy_id: Mapped[str] = mapped_column(String(64), unique=True, index=True)
    email: Mapped[str] = mapped_column(String(320), unique=True, nullable=True)
    phone: Mapped[str] = mapped_column(String(32), unique=True, nullable=True)
    created_at: Mapped[datetime.datetime] = mapped_column(
        # default=datetime.datetime.now(datetime.UTC)
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )

    wallets: Mapped[list["Wallet"]] = relationship(
        back_populates="user", lazy="selectin"
    )

=== models/token.py ===
from __future__ import annotations
import uuid
from app.db.base import Base

# from app.models import Business
from app.utils import uuid_pk
from decimal import Decimal
from sqlalchemy import (
    CheckConstraint,
    BigInteger,
    ForeignKey,
    Boolean,
    Numeric,
    Integer,
    String,
    Index,
    text,
)
from sqlalchemy.orm import (
    Mapped,
    mapped_column,
    relationship,
)


class Token(Base):
    __tablename__ = "tokens"
    __table_args__ = (
        CheckConstraint("min_rate <= max_rate", name="check_min_le_max_rate"),
        CheckConstraint("decimals BETWEEN 0 AND 9", name="check_decimals_range"),
        Index(
            "uq_single_loyl",
            "settlement_token",
            unique=True,
            postgresql_where=text("settlement_token IS TRUE"),
        ),
    )

    id: Mapped[uuid.UUID] = uuid_pk()
    mint: Mapped[str] = mapped_column(String(64), unique=True, index=True)
    symbol: Mapped[str] = mapped_column(String(6), unique=True)
    coin_logo_url: Mapped[str | None] = mapped_column(String(512))
    decimals: Mapped[int] = mapped_column(Integer, default=2)
    business_id: Mapped[uuid.UUID | None] = mapped_column(
        ForeignKey("businesses.id", ondelete="SET NULL")
    )
    settlement_token: Mapped[bool] = mapped_column(
        Boolean, default=False
    )  # flag for LOYL

    rate_loyl: Mapped[Decimal] = mapped_column(Numeric(18, 6), nullable=False)

    # need to check later
    min_rate: Mapped[Decimal | None] = mapped_column(
        Numeric(18, 6),
    )
    max_rate: Mapped[Decimal | None] = mapped_column(
        Numeric(18, 6),
    )

    total_supply: Mapped[int] = mapped_column(
        BigInteger,
        nullable=False,
        default=0,
        comment="Current totalSupply (base-units)",
    )

    business: Mapped["Business"] = relationship(
        back_populates="loyalty_token", lazy="selectin"
    )

    @property
    def base_units(self) -> int:
        return 10**self.decimals

=== models/tasks.py ===
from __future__ import annotations
import uuid, enum, datetime
from app.db.base import Base
from app.utils import uuid_pk
from sqlalchemy import BigInteger, String, JSON, Enum as PgEnum, DateTime
from sqlalchemy.orm import Mapped, mapped_column
from sqlalchemy.sql import func


class TaskStatus(str, enum.Enum):
    PENDING = "pending"
    SUCCESS = "success"
    FAILED = "failed"
    RETRY = "retry"


class CeleryTaskLog(Base):
    __tablename__ = "celery_task_logs"

    id: Mapped[uuid.UUID] = uuid_pk()
    task_id: Mapped[str] = mapped_column(String(50), unique=True, nullable=False)
    queue: Mapped[str] = mapped_column(String(32), index=True)
    status: Mapped[TaskStatus] = mapped_column(
        PgEnum(TaskStatus, name="task_status_enum"),
        index=True,
    )
    payload: Mapped[dict | None] = mapped_column(JSON)
    result: Mapped[str | None] = mapped_column(String(32))
    # duration: Mapped[datetime.timedelta] = mapped_column() # maybe add later
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )
    updated_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )

=== models/promotion.py ===
from __future__ import annotations
import enum, uuid, datetime
from decimal import Decimal
from sqlalchemy import (
    String,
    BigInteger,
    Numeric,
    DateTime,
    ForeignKey,
    UniqueConstraint,
    CheckConstraint,
    Enum as PgEnum,
)
from sqlalchemy.orm import Mapped, mapped_column, relationship
from app.db.base import Base
from app.utils import uuid_pk


class PromotionType(str, enum.Enum):
    DISCOUNT = "discount"


class PromotionCampaign(Base):
    """
    Promotion campaign bound to a business loyalty token.
    """

    __tablename__ = "promotion_campaigns"
    __table_args__ = (
        UniqueConstraint("business_id", "name", name="uq_campaign_name_biz"),
        CheckConstraint("price_points > 0", name="check_positive_price"),
        CheckConstraint("discount_pct BETWEEN 1 AND 100", name="check_pct_range"),
    )

    id: Mapped[uuid.UUID] = uuid_pk()
    business_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("businesses.id", ondelete="CASCADE")
    )
    name: Mapped[str] = mapped_column(String(128))
    promo_type: Mapped[PromotionType] = mapped_column(
        PgEnum(PromotionType, name="promo_type_enum")
    )
    price_points: Mapped[int] = mapped_column(BigInteger)
    discount_pct: Mapped[int] = mapped_column(
        Numeric(5, 2),
        comment="Percent discount applied to purchase amount",
    )
    active_from: Mapped[datetime.datetime | None] = mapped_column(
        DateTime(timezone=True)
    )
    active_to: Mapped[datetime.datetime | None] = mapped_column(DateTime(timezone=True))

    business: Mapped["Business"] = relationship(lazy="noload")

=== models/transactions.py ===
from __future__ import annotations
import uuid, enum, datetime
from app.db.base import Base
from app.models import Wallet, Token, User
from app.utils import uuid_pk
from sqlalchemy import (
    CheckConstraint,
    ForeignKey,
    BigInteger,
    String,
    Enum as PgEnum,
    DateTime,
)
from sqlalchemy.orm import (
    Mapped,
    mapped_column,
    relationship,
)
from sqlalchemy.sql import func


class TxType(str, enum.Enum):
    EARN = "earn"
    REDEEM = "redeem"
    SWAP_IN = "swap_in" # user → platform
    SWAP_OUT = "swap_out" # platform → user

class TxStatus(str, enum.Enum):
    PENDING = "pending"
    SUCCESS = "success"
    FAILED = "failed"


class PointTx(Base):
    __tablename__ = "point_txs"
    __table_args__ = (CheckConstraint("fee_bps BETWEEN 0 AND 10000"),)

    id: Mapped[uuid.UUID] = uuid_pk()
    wallet_id: Mapped[uuid.UUID | None] = mapped_column(
        ForeignKey("wallets.id", ondelete="SET NULL"),
        index=True,
    )
    token_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("tokens.id"))
    tx_type: Mapped[TxType] = mapped_column(PgEnum(TxType, name="tx_type_enum"))
    amount: Mapped[int] = mapped_column(BigInteger)
    fee_bps: Mapped[int | None]
    sol_sig: Mapped[str | None] = mapped_column(String(128))
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )

    wallet: Mapped["Wallet"] = relationship(lazy="noload", foreign_keys=[wallet_id])
    token: Mapped["Token"] = relationship(lazy="noload", foreign_keys=[token_id])


class SwapTx(Base):
    __tablename__ = "swap_txs"
    __table_args__ = (CheckConstraint("from_amount > 0 AND to_amount > 0"),)

    id: Mapped[uuid.UUID] = uuid_pk()
    user_id: Mapped[uuid.UUID | None] = mapped_column(
        ForeignKey("users.id", ondelete="SET NULL"),
        index=True,
    )
    from_token_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("tokens.id"))
    to_token_id: Mapped[uuid.UUID] = mapped_column(ForeignKey("tokens.id"))
    from_amount: Mapped[int] = mapped_column(BigInteger)
    to_amount: Mapped[int] = mapped_column(BigInteger)
    fee_bps: Mapped[int]
    # Signature for platform → user (second leg)
    sol_sig: Mapped[str | None] = mapped_column(String(128))
    # Signature for user → platform (first leg)
    sol_sig_redeem: Mapped[str | None] = mapped_column(String(128))
    status: Mapped[TxStatus] = mapped_column(PgEnum(TxStatus, name="tx_status_enum"), default=TxStatus.PENDING)
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )

    user: Mapped["User"] = relationship(lazy="noload")

=== models/__init__.py ===
from .user import User
from .wallet import Wallet
from .business import Business, BusinessReview
from .token import Token
from .balance import Balance
from .transactions import TxType, TxStatus, PointTx, SwapTx
from .voucher import VoucherStatus, VoucherTemplate, VoucherNFT
from .tasks import TaskStatus, CeleryTaskLog
from .token_pool import TokenPool
from .promotion import PromotionCampaign

=== models/business.py ===
from __future__ import annotations
import uuid, datetime
from decimal import Decimal
from typing import TYPE_CHECKING, List
from sqlalchemy.ext.hybrid import hybrid_property
from app.db.base import Base
# from app.models import VoucherTemplate, Token
from app.utils import uuid_pk
from sqlalchemy.sql import func
from sqlalchemy import (
    CheckConstraint,
    String,
    DateTime,
    Numeric,
    ForeignKey,
    select,
)
from sqlalchemy.orm import (
    Mapped,
    mapped_column,
    relationship,
    column_property,
)


if TYPE_CHECKING:
    from app.models.voucher import VoucherTemplate
    from app.models.token import Token

class BusinessReview(Base):
    __tablename__ = "business_reviews"
    __table_args__ = (
        CheckConstraint("score >= 1 AND score <= 5", name="check_score_range"),
    )

    id: Mapped[int] = mapped_column(primary_key=True)
    business_id: Mapped[int] = mapped_column(ForeignKey("business.id", ondelete="CASCADE"))
    business: Mapped[Business] = relationship(
        "Business",
        back_populates="reviews",
        lazy="joined",
    )
    user_id: Mapped[int] = mapped_column(ForeignKey("user.id", ondelete="CASCADE"))
    score: Mapped[Decimal] = mapped_column(
        Numeric(3, 2),
        nullable=False,
        comment="Score from 1.00 to 5.00",
    )
    review_text: Mapped[str] = mapped_column(String(512))
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )

class Business(Base):
    __tablename__ = "businesses"
    __table_args__ = (
        CheckConstraint("length(slug) >= 3", name="check_slug_min_length"),
    )

    id: Mapped[uuid.UUID] = uuid_pk()
    name: Mapped[str] = mapped_column(String(128), unique=True)
    slug: Mapped[str] = mapped_column(String(64), unique=True, index=True)
    logo_url: Mapped[str | None] = mapped_column(String(512))
    owner_email: Mapped[str] = mapped_column(String(320), index=True)
    owner_pubkey:  Mapped[str] = mapped_column(String(44), nullable=False, unique=True, index=True)
    owner_privkey: Mapped[str] = mapped_column(String(88))
    description: Mapped[str] = mapped_column(String(512))
    country: Mapped[str] = mapped_column(String(64))
    city: Mapped[str] = mapped_column(String(128))
    address: Mapped[str] = mapped_column(String(128))
    zip_code: Mapped[str] = mapped_column(String(12))
    rate_loyl: Mapped[Decimal] = mapped_column(
        Numeric(18, 6),
        nullable=False,
        comment="Rate branded token to LOYL",
    )
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )
    updated_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
        nullable=False,
    )
    loyalty_token: Mapped["Token"] = relationship(
        "Token",
        back_populates="business",
        uselist=False,
        lazy="selectin",
    )
    voucher_templates: Mapped[List["VoucherTemplate"]] = relationship(
        "VoucherTemplate",
        back_populates="business",
        cascade="all, delete-orphan",
        lazy="selectin",
    )
    reviews: Mapped[List["BusinessReview"]] = relationship(
        "BusinessReview",
        back_populates="business",
        cascade="all, delete-orphan",
        lazy="selectin",
    )

    @hybrid_property
    def rating(self) -> float:
        if not hasattr(self, "reviews") or not self.reviews:
            return 0.0
        return float(sum([r.score for r in self.reviews]) / len(self.reviews))

    rating_db = column_property(
        select(func.avg(BusinessReview.score))
        .where(BusinessReview.business_id == id)
        .correlate_except(BusinessReview)
        .scalar_subquery()
    )



=== models/voucher.py ===
from __future__ import annotations
import uuid, enum, datetime
from app.db.base import Base
from app.utils import uuid_pk
from sqlalchemy import (
    ForeignKey,
    UniqueConstraint,
    BigInteger,
    String,
    Enum as PgEnum,
    DateTime,
)
from sqlalchemy.orm import (
    Mapped,
    mapped_column,
    relationship,
)
from sqlalchemy.sql import func


class VoucherStatus(str, enum.Enum):
    ACTIVE = "active"
    REDEEMED = "redeemed"
    EXPIRED = "expired"


class VoucherTemplate(Base):
    __tablename__ = "voucher_templates"

    id: Mapped[uuid.UUID] = uuid_pk()
    business_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("businesses.id", ondelete="CASCADE")
    )
    name: Mapped[str] = mapped_column(String(128))
    description: Mapped[str | None] = mapped_column(String(320))
    image_url: Mapped[str | None] = mapped_column(String(320))
    price_points: Mapped[int] = mapped_column(BigInteger)
    supply: Mapped[int]
    expires_at: Mapped[datetime.datetime | None]
    collection_mint: Mapped[str | None] = mapped_column(String(64), unique=True)

    vouchers: Mapped[list["VoucherNFT"]] = relationship(
        back_populates="template",
        lazy="selectin",
        cascade="all, delete-orphan",
        passive_deletes=True,
    )
    business: Mapped["Business"] = relationship(
        back_populates="voucher_templates", lazy="selectin"
    )


class VoucherNFT(Base):
    __tablename__ = "voucher_nfts"
    __table_args__ = (
        UniqueConstraint("template_id", "asset_id", name="uq_template_asset"),
    )

    id: Mapped[uuid.UUID] = uuid_pk()
    template_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("voucher_templates.id", ondelete="CASCADE")
    )

    user_id: Mapped[uuid.UUID | None] = mapped_column(
        ForeignKey("users.id", ondelete="SET NULL"),
    )
    asset_id: Mapped[str] = mapped_column(String(128))
    status: Mapped[VoucherStatus] = mapped_column(
        PgEnum(VoucherStatus, name="voucher_status_enum"),
        default=VoucherStatus.ACTIVE,
    )
    redeemed_at: Mapped[datetime.datetime | None] = mapped_column(
        DateTime(timezone=True),
        nullable=True,
        default=None,
    )
    created_at: Mapped[datetime.datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )

    template: Mapped[VoucherTemplate] = relationship(
        back_populates="vouchers", lazy="selectin"
    )

    user: Mapped["User"] = relationship(lazy="noload")

=== models/balance.py ===
from __future__ import annotations
import uuid
from datetime import datetime
from app.db.base import Base
from app.models import Wallet
from app.models import Token
from app.utils import uuid_pk
from decimal import Decimal
from sqlalchemy.sql import func
from sqlalchemy.orm import Mapped, mapped_column, relationship
from sqlalchemy import ForeignKey, UniqueConstraint, DateTime, BigInteger


class Balance(Base):
    __tablename__ = "balances"
    __table_args__ = (
        UniqueConstraint("wallet_id", "token_id", name="uq_wallet_token"),
    )

    id: Mapped[uuid.UUID] = uuid_pk()
    wallet_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("wallets.id", ondelete="CASCADE"),  # maybe need to add index
    )
    token_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("tokens.id", ondelete="CASCADE"),  # maybe need to add index
    )
    amount: Mapped[int] = mapped_column(BigInteger)

    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )
    updated_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True),
        server_default=func.now(),
        onupdate=func.now(),
    )

    wallet: Mapped["Wallet"] = relationship(lazy="noload")
    token: Mapped["Token"] = relationship(lazy="noload")

=== models/wallet.py ===
from __future__ import annotations
import uuid
import datetime
from app.db.base import Base
from app.utils import uuid_pk

# from app.models import User
from sqlalchemy.sql import func
from sqlalchemy import (
    ForeignKey,
    UniqueConstraint,
    String,
    DateTime,
)
from sqlalchemy.orm import (
    Mapped,
    mapped_column,
    relationship,
)


class Wallet(Base):
    __tablename__ = "wallets"
    __table_args__ = (UniqueConstraint("user_id", "pubkey", name="uq_user_pubkey"),)
    id: Mapped[uuid.UUID] = uuid_pk()
    user_id: Mapped[uuid.UUID] = mapped_column(
        ForeignKey("users.id", ondelete="CASCADE")
    )
    pubkey: Mapped[str] = mapped_column(String(44), unique=True, index=True)
    created_at: Mapped[datetime.datetime] = mapped_column(
        # default=datetime.datetime.now(datetime.UTC)
        DateTime(timezone=True),
        server_default=func.now(),
        nullable=False,
    )
    user: Mapped["User"] = relationship(back_populates="wallets", lazy="noload")

=== schemas/user.py ===
from app.schemas.base import BaseSchema, BaseDBSchema
from pydantic import EmailStr
from app.schemas.types import PhoneStr, PrivyIDStr


class UserCreate(BaseSchema):
    privy_id: PrivyIDStr
    phone: PhoneStr
    email: EmailStr


class UserUpdate(BaseSchema):
    phone: PhoneStr | None = None
    email: EmailStr | None = None


class UserOut(BaseDBSchema):
    privy_id: PrivyIDStr
    phone: PhoneStr
    email: EmailStr

=== schemas/token.py ===
from uuid import UUID
from pydantic import AnyUrl
from app.schemas.base import BaseSchema, BaseDBSchema
from app.schemas.types import (
    MintStr,
    SymbolStr,
    Decimals,
    RateDecimals,
)


class TokenCreate(BaseSchema):
    mint: MintStr
    symbol: SymbolStr
    coin_logo_url: AnyUrl | None
    min_rate: RateDecimals | None
    max_rate: RateDecimals | None
    business_id: UUID | None = None
    settlement_token: bool | None = False
    decimals: Decimals = 2


class TokenUpdate(BaseSchema):
    coin_logo_url: AnyUrl | None
    min_rate: RateDecimals | None
    max_rate: RateDecimals | None


class TokenOut(TokenCreate, BaseDBSchema):
    mint: MintStr
    symbol: SymbolStr
    coin_logo_url: AnyUrl | None
    min_rate: RateDecimals | None
    max_rate: RateDecimals | None
    business_id: UUID | None
    settlement_token: bool | None
    decimals: Decimals

=== schemas/tasks.py ===
import datetime
from uuid import UUID
from pydantic import json
from app.schemas.types import LimitedStr, TaskStatusEnum
from app.schemas.base import BaseSchema, BaseDBSchema


class CeleryTaskLogCreate(BaseSchema):
    task_id: LimitedStr(1, 50)
    queue: LimitedStr(1, 32)
    status: TaskStatusEnum
    payload: dict | None
    result: LimitedStr(1, 32) | None


class CeleryTaskLogUpdate(BaseSchema):
    status: TaskStatusEnum = None
    payload: dict | None = None
    result: LimitedStr(1, 32) | None = None


class CeleryTaskLogOut(BaseDBSchema):
    task_id: LimitedStr(1, 50)
    queue: LimitedStr(1, 32)
    status: TaskStatusEnum
    payload: dict | None
    result: LimitedStr(1, 32) | None

=== schemas/promotion.py ===
from uuid import UUID
from datetime import datetime
from pydantic import BaseModel, conint
from app.schemas.base import BaseDBSchema
from app.models.promotion import PromotionType


class PromotionCreate(BaseModel):
    business_id: UUID
    name: str
    promo_type: PromotionType = PromotionType.DISCOUNT
    price_points: conint(gt=0)
    discount_pct: conint(gt=0, le=100)
    active_from: datetime | None = None
    active_to: datetime | None = None


class PromotionUpdate(BaseModel):
    name: str | None = None
    price_points: conint(gt=0) | None = None
    discount_pct: conint(gt=0, le=100) | None = None
    active_from: datetime | None = None
    active_to: datetime | None = None


class PromotionOut(BaseDBSchema):
    business_id: UUID
    name: str
    promo_type: PromotionType = PromotionType.DISCOUNT
    price_points: conint(gt=0)
    discount_pct: conint(gt=0, le=100)
    active_from: datetime | None = None
    active_to: datetime | None = None

=== schemas/swap_tx.py ===
from uuid import UUID
from app.schemas.base import BaseSchema, BaseDBSchema
from app.schemas.types import TxTypeEnum, GeZero, FeeBpsInt, SolSigStr


class SwapTxCreate(BaseSchema):
    user_id: UUID
    from_token_id: UUID
    to_token_id: UUID
    from_amount: GeZero
    to_amount: GeZero
    fee_bps: FeeBpsInt
    sol_sig: SolSigStr
    sol_sig_redeem: SolSigStr


class SwapTxOut(BaseDBSchema):
    user_id: UUID
    from_token_id: UUID
    to_token_id: UUID
    from_amount: GeZero
    to_amount: GeZero
    fee_bps: FeeBpsInt
    sol_sig: SolSigStr
    sol_sig_redeem: SolSigStr

=== schemas/point_tx.py ===
from uuid import UUID
from app.schemas.base import BaseSchema, BaseDBSchema
from app.schemas.types import TxTypeEnum, GeZero, FeeBpsInt, SolSigStr


class PointTxCreate(BaseSchema):
    wallet_id: UUID
    tx_type: TxTypeEnum
    token_id: UUID
    amount: GeZero
    fee_bps: FeeBpsInt | None
    sol_sig: SolSigStr | None


class PointTxOut(BaseDBSchema):
    wallet_id: UUID
    tx_type: TxTypeEnum
    token_id: UUID
    amount: GeZero
    fee_bps: FeeBpsInt | None
    sol_sig: SolSigStr | None

=== schemas/__init__.py ===

=== schemas/types.py ===
from pydantic import constr, conint, condecimal

from app.models.voucher import VoucherStatus
from app.models.transactions import TxType
from app.models.tasks import TaskStatus


def LimitedStr(min_length: int = 1, max_length: int = 128):
    return constr(min_length=min_length, max_length=max_length)


def ExactLenStr(length: int = 64):
    return constr(min_length=length, max_length=length)


PrivyIDStr = ExactLenStr(64)
MediumStr = LimitedStr(1, 128)
PhoneStr = LimitedStr(5, 32)
NameStr = LimitedStr(1, 128)
SlugStr = LimitedStr(1, 64)
TextAreaStr = LimitedStr(1, 512)
CountryStr = LimitedStr(2, 64)
CityStr = LimitedStr(1, 128)
AddressStr = LimitedStr(1, 128)
ZipCodeStr = LimitedStr(1, 12)
SymbolStr = LimitedStr(3, 6)
MintStr = ExactLenStr(64)
Decimals = conint(ge=0, le=9)
RateDecimals = condecimal(max_digits=18, decimal_places=6)
GeZero = condecimal(ge=0, max_digits=38, decimal_places=0)
TxTypeEnum = TxType
FeeBpsInt = conint(ge=0, le=10_000)
SolSigStr = LimitedStr(1, 128)
VouchStatEnum = VoucherStatus
TaskStatusEnum = TaskStatus
RatingInt = condecimal(gt=0, le=5, max_digits=3, decimal_places=2)
OwnerPrivKey = LimitedStr(88, 88)
PubkeyStr = constr(min_length=44, max_length=44)

=== schemas/review.py ===
from uuid import UUID
from decimal import Decimal
from datetime import datetime
from pydantic import BaseModel
from app.schemas.types import RatingInt
from app.schemas.base import BaseDBSchema, BaseSchema

class ReviewCreate(BaseSchema):
    business_id: UUID
    user_id: UUID
    score: RatingInt
    review_text: str

class ReviewOut(BaseDBSchema):
    business_id: UUID
    user_id: UUID
    score: Decimal
    review_text: str
    created_at: datetime

=== schemas/business.py ===
from app.schemas.base import BaseSchema, BaseDBSchema
from pydantic import EmailStr, AnyUrl
from app.schemas.types import (
    NameStr,
    SlugStr,
    TextAreaStr,
    CountryStr,
    CityStr,
    AddressStr,
    ZipCodeStr,
    RateDecimals,
    RatingInt,
    OwnerPrivKey,
    PubkeyStr,
)



class BusinessCreate(BaseSchema):
    name: NameStr
    slug: SlugStr
    logo_url: AnyUrl | None = None
    owner_email: EmailStr
    # owner_pubkey: OwnerPrivKey
    # owner_privkey: OwnerPrivKey
    description: TextAreaStr
    country: CountryStr
    city: CityStr
    address: AddressStr
    zip_code: ZipCodeStr
    rate_loyl: RateDecimals


class BusinessUpdate(BaseSchema):
    name: NameStr | None = None
    slug: SlugStr | None = None
    logo_url: AnyUrl | None = None
    owner_email: EmailStr | None = None
    # owner_privkey: OwnerPrivKey | None = None
    description: TextAreaStr | None = None
    country: CountryStr | None = None
    city: CityStr | None = None
    address: AddressStr | None = None
    zip_code: ZipCodeStr | None = None
    rate_loyl: RateDecimals | None = None


class BusinessOut(BaseDBSchema):
    name: NameStr
    slug: SlugStr
    logo_url: AnyUrl | None
    owner_email: EmailStr
    owner_pubkey: PubkeyStr
    # owner_privkey: OwnerPrivKey
    description: TextAreaStr
    rating: RatingInt
    country: CountryStr
    city: CityStr
    address: AddressStr
    zip_code: ZipCodeStr
    rate_loyl: RateDecimals

=== schemas/voucher.py ===
from datetime import datetime
from uuid import UUID
from pydantic import AnyUrl
from app.schemas.base import BaseSchema, BaseDBSchema
from app.schemas.types import (
    NameStr,
    TextAreaStr,
    Decimals,
    GeZero,
    MintStr,
    MediumStr,
    VouchStatEnum,
)


class VoucherTemplateCreate(BaseSchema):
    business_id: UUID
    name: NameStr
    description: TextAreaStr | None
    image_url: AnyUrl | None
    price_points: Decimals
    supply: GeZero
    expires_at: datetime | None
    collection_mint: MintStr | None


class VoucherTemplateUpdate(BaseSchema):
    expires_at: datetime | None = None


class VoucherTemplateOut(BaseDBSchema):
    business_id: UUID
    name: NameStr
    description: TextAreaStr | None
    image_url: AnyUrl | None
    price_points: Decimals
    supply: GeZero
    expires_at: datetime | None
    collection_mint: MintStr | None


class VoucherNFTCreate(BaseSchema):
    template_id: UUID
    user_id: UUID | None
    asset_id: MediumStr
    status: VouchStatEnum
    redeemed_at: datetime | None


class VoucherNFTUpdate(BaseSchema):
    user_id: UUID | None = None
    status: VouchStatEnum | None = None
    redeemed_at: datetime | None = None


class VoucherNFTOut(BaseDBSchema):
    template_id: UUID
    user_id: UUID | None
    asset_id: MediumStr
    status: VouchStatEnum
    redeemed_at: datetime | None

=== schemas/balance.py ===
from datetime import datetime
from uuid import UUID
from app.schemas.types import GeZero
from app.schemas.base import BaseSchema, BaseDBSchema


class BalanceCreate(BaseSchema):
    wallet_id: UUID
    token_id: UUID
    amount: GeZero


class BalanceUpdate(BaseSchema):
    amount: GeZero


class BalanceOut(BaseDBSchema):
    wallet_id: UUID
    token_id: UUID
    amount: GeZero
    updated_at: datetime

=== schemas/base.py ===
from uuid import UUID
from datetime import datetime
from pydantic import BaseModel


class BaseSchema(BaseModel):
    model_config = {
        "from_attributes": True,
        "arbitrary_types_allowed": True,
    }


class BaseDBSchema(BaseSchema):
    id: UUID
    created_at: datetime
    updated_at: datetime

=== schemas/wallet.py ===
from uuid import UUID
from pydantic import BaseModel
from app.schemas.base import BaseSchema, BaseDBSchema


class WalletCreate(BaseSchema):
    user_id: UUID
    pubkey: str


class WalletUpdate(BaseSchema):
    pass


class WalletOut(BaseDBSchema):
    user_id: UUID
    pubkey: str

=== fastapi_code.txt ===

=== utils.py ===
import uuid
from sqlalchemy import UUID
from sqlalchemy.orm import mapped_column, Mapped


def uuid_pk() -> Mapped[uuid.UUID]:
    return mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

=== crud/__init__.py ===

=== crud/base.py ===
from typing import Generic, Type, TypeVar
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, delete
from sqlalchemy.sql import ColumnElement
from pydantic import BaseModel
from app.db.base import Base
from uuid import UUID

ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)
OutSchemaType = TypeVar("OutSchemaType", bound=BaseModel)


class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):  # , OutSchema
    def __init__(self, model: Type[ModelType]):
        self.model = model

    async def create(self, db: AsyncSession, obj_in: CreateSchemaType) -> ModelType:
        obj = self.model(**obj_in.model_dump())
        db.add(obj)
        await db.commit()
        await db.refresh(obj)
        return obj

    async def read(self, db: AsyncSession, id_: str | UUID) -> ModelType | None:
        id_ = UUID(str(id_))
        res = await db.execute(select(self.model).where(id_ == self.model.id))
        return res.scalar_one_or_none()

    async def read_many(
        self,
        db: AsyncSession,
        start: int = 0,
        limit: int = 10,
        filters: list[ColumnElement[bool]] | None = None,
    ) -> list[ModelType]:
        data = select(self.model)
        if filters:
            for condition in filters:
                data = data.where(condition)
        data = data.offset(start).limit(limit)
        res = await db.execute(data)
        return list(res.scalars())

    async def update(
        self, db: AsyncSession, db_obj: ModelType, obj_in: UpdateSchemaType
    ) -> ModelType:
        for k, v in obj_in.model_dump(exclude_unset=True).items():
            setattr(db_obj, k, v)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def delete(self, db: AsyncSession, id_: str | UUID) -> None:
        id_ = UUID(str(id_))
        await db.execute(delete(self.model).where(id_ == self.model.id))
        await db.commit()

=== db/session.py ===
from collections.abc import AsyncGenerator
from sqlalchemy.ext.asyncio import (
    AsyncEngine,
    AsyncSession,
    create_async_engine,
    async_sessionmaker,
)
from app.core.settings import settings

engine: AsyncEngine = create_async_engine(
    settings.database_url,
    echo=(settings.ENV == "dev"),
    future=True,
)

AsyncSessionLocal = async_sessionmaker(
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)


async def get_db() -> AsyncGenerator[AsyncSession, None]:
    async with AsyncSessionLocal() as session:
        yield session

=== db/__init__.py ===

=== db/base.py ===
from __future__ import annotations
from sqlalchemy.orm import DeclarativeBase


class Base(DeclarativeBase):
    repr_cols_num = 2  # just for __repr__

=== api/v1/swap_txs.py ===
from app.api.crud_router import create_crud_router
from app.services.swap_tx import swap_tx_service
from app.schemas.swap_tx import SwapTxCreate, SwapTxOut

router = create_crud_router(
    crud=swap_tx_service.crud,
    create_schema=SwapTxCreate,
    update_schema=SwapTxCreate,
    out_schema=SwapTxOut,
    prefix="/swap_txs",
    tags=["swap_txs"],
)

=== api/v1/auth.py ===
from fastapi import APIRouter, Depends, Request, HTTPException, status
from starlette.responses import RedirectResponse
from app.core.settings import settings
from app.services.privy_client import PrivyClient, verify_sig
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.session import get_db
from app.services.user import user_service
from app.services.wallet import wallet_service
from app.core.security import verify_privy_token


router = APIRouter(prefix="/auth", tags=["auth"])
privy = PrivyClient(settings.PRIVY_APP_ID, settings.PRIVY_API_KEY)

auth_scheme = HTTPBearer(auto_error=False)
privy_rest = PrivyClient(settings.PRIVY_APP_ID, settings.PRIVY_API_KEY)


@router.post("/handshake", status_code=204, dependencies=[])
async def privy_handshake(
    creds: HTTPAuthorizationCredentials = Depends(auth_scheme),
    db: AsyncSession = Depends(get_db),
):
    """
    1) Checking access-token.
    2) If user is absent — creating and minting embedded-wallet.
    """
    if not creds:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)

    claims = verify_privy_token(creds.credentials)  # → did, sid
    user = await user_service.create_or_get(
        db,
        privy_id=claims.did,
        email="",  # maybe webhook (BUT WEBHOOK IN PRO SUBSCRIPTION)
        phone="",
    )

    # embeddedWallet created on frontend; just save pubkey,
    # but if wallet absent - creating on the server
    if not user.wallets:
        address = await privy_rest.create_wallets(claims.did)
        await wallet_service.add_if_missing(db, user, address)

    # if not user.wallets:
    #     w = await privy_rest.create_wallet(
    #         chain="solana"
    #     )  # :contentReference[oaicite:2]{index=2}
    #     await wallet_service.add_if_missing(db, user, w["address"])

    return  # 204


@router.get("/callback")
async def privy_callback(code: str, db: AsyncSession = Depends(get_db)):
    """
    Get privy_id by code, creating user and hidden-wallet.
    """
    # exchange code → privy_id
    privy_id = await privy.exchange_code(code)  # needs method later
    p_user = await privy.get_user(privy_id)

    user = await user_service.create_or_get(
        db,
        privy_id=p_user.id,
        email="",  # Privy e-mail will come later as web-hook
        phone="",
    )
    # creating Wallet (ATA = embedded_wallet)
    await wallet_service.add_if_missing(db, user, p_user.embedded_wallet)

    return RedirectResponse(url="/")  # frontend gets session cookkie


@router.post("/webhook")
async def privy_webhook(request: Request, db: AsyncSession = Depends(get_db)):
    """
    Listening events on 'user.updated', update e-mail / phone.
    """
    sig = request.headers.get("privy-signature")
    body = await request.body()
    if not verify_sig(sig, body, settings.PRIVY_API_SECRET):
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN)

    event = await request.json()
    if event["type"] == "user.updated":
        privy_id = event["data"]["id"]
        email = event["data"]["email"]
        phone = event["data"]["phone"]
        user = await user_service.get_by_privy(db, privy_id)
        if user:
            await user_service.update(db, user, {"email": email, "phone": phone})
    return {"ok": True}

=== api/v1/voucher_templates.py ===
from app.api.crud_router import create_crud_router
from app.services.voucher_template import voucher_template_service
from app.schemas.voucher import (
    VoucherTemplateCreate,
    VoucherTemplateUpdate,
    VoucherTemplateOut,
)

router = create_crud_router(
    crud=voucher_template_service.crud,
    create_schema=VoucherTemplateCreate,
    update_schema=VoucherTemplateUpdate,
    out_schema=VoucherTemplateOut,
    prefix="/voucher_templates",
    tags=["voucher_templates"],
)

=== api/v1/reviews.py ===
from fastapi import APIRouter, Depends, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.review import review_service
from app.schemas.review import ReviewCreate, ReviewOut
from app.api.deps import get_db

router = APIRouter(prefix="/reviews", tags=["reviews"])

@router.post("/", response_model=ReviewOut, status_code=status.HTTP_201_CREATED)
async def create_review(payload: ReviewCreate, db: AsyncSession = Depends(get_db)):
    return await review_service.create(db, payload)

=== api/v1/tasks.py ===
from app.api.crud_router import create_crud_router
from app.services.task import celery_task_service
from app.schemas.tasks import CeleryTaskLogCreate, CeleryTaskLogUpdate, CeleryTaskLogOut

router = create_crud_router(
    crud=celery_task_service.crud,
    create_schema=CeleryTaskLogCreate,
    update_schema=CeleryTaskLogUpdate,
    out_schema=CeleryTaskLogOut,
    prefix="/tasks",
    tags=["tasks"],
)

=== api/v1/users.py ===
from typing import Annotated, List, Union
from uuid import UUID
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.api.deps import get_db
from app.services.user import user_service
from app.schemas.user import UserCreate, UserUpdate, UserOut

router = APIRouter(prefix="/users", tags=["users"])


@router.post("/", response_model=UserOut, status_code=status.HTTP_201_CREATED)
async def create_user(
    payload: UserCreate,
    db: Annotated[AsyncSession, Depends(get_db)],
) -> UserOut:
    return await user_service.create(db, payload)


@router.get("/{user_id}", response_model=UserOut)
async def read_user(
    user_id: Union[str, UUID],
    db: Annotated[AsyncSession, Depends(get_db)],
) -> UserOut:
    user = await user_service.read(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    return user


@router.get("/", response_model=List[UserOut])
async def read_users(
    db: Annotated[AsyncSession, Depends(get_db)],
    start: int = 0,
    limit: int = 10,
) -> List[UserOut]:
    return await user_service.read_many(db, start=start, limit=limit)


@router.patch("/{user_id}", response_model=UserOut)
async def update_user(
    user_id: Union[str, UUID],
    payload: UserUpdate,
    db: Annotated[AsyncSession, Depends(get_db)],
) -> UserOut:
    user = await user_service.read(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    return await user_service.update(db, user, payload)


@router.delete("/{user_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_user(
    user_id: Union[str, UUID],
    db: Annotated[AsyncSession, Depends(get_db)],
) -> None:
    user = await user_service.read(db, user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    await user_service.delete(db, user_id)

=== api/v1/token_minting.py ===
from fastapi import APIRouter, Depends, HTTPException, Path
from typing import Annotated
from sqlalchemy.ext.asyncio import AsyncSession
from app.api.deps import get_db
from app.models import Business, Token, TokenPool
from sqlalchemy import select
from pydantic import BaseModel, UUID4

router = APIRouter(prefix="/token-minting", tags=["token-minting"])


class TokenMintingStatusResponse(BaseModel):
    business_id: UUID4
    business_name: str
    token_created: bool
    token_symbol: str | None = None
    token_mint_address: str | None = None
    pool_initialized: bool = False
    pool_balance_token: int | None = None
    pool_balance_loyl: int | None = None


@router.get("/status/{business_id}", response_model=TokenMintingStatusResponse)
async def get_token_minting_status(
    business_id: Annotated[UUID4, Path(...)], 
    db: Annotated[AsyncSession, Depends(get_db)]
):
    """
    Check the status of token minting for a specific business.
    Returns information about the token and pool creation status.
    """
    # Query the business
    business_query = await db.execute(
        select(Business).where(Business.id == business_id)
    )
    business = business_query.scalar_one_or_none()
    
    if not business:
        raise HTTPException(status_code=404, detail="Business not found")
    
    # Prepare the response
    response = TokenMintingStatusResponse(
        business_id=business.id,
        business_name=business.name,
        token_created=False
    )
    
    # Check if token was created
    if business.loyalty_token:
        token = business.loyalty_token
        response.token_created = True
        response.token_symbol = token.symbol
        response.token_mint_address = token.mint
        
        # Check if pool was initialized
        pool_query = await db.execute(
            select(TokenPool).where(TokenPool.token_id == token.id)
        )
        pool = pool_query.scalar_one_or_none()
        
        if pool:
            response.pool_initialized = True
            response.pool_balance_token = pool.balance_token
            response.pool_balance_loyl = pool.balance_loyl
    
    return response

=== api/v1/voucher_mint.py ===
from fastapi import APIRouter, Depends, status, HTTPException
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from app.api.deps import get_db
from app.tasks.voucher import mint_voucher_task
from app.models import VoucherTemplate
from app.schemas.voucher import VoucherNFTOut

router = APIRouter(prefix="/voucher", tags=["vouchers"])

@router.post(
    "/template/{template_id}/mint",
    response_model=VoucherNFTOut,
    status_code=status.HTTP_202_ACCEPTED,
)
async def mint_voucher(template_id: UUID, user_id: UUID, db: AsyncSession = Depends(get_db)):
    tmpl = await db.get(VoucherTemplate, template_id)
    if not tmpl:
        raise HTTPException(404, "template not found")
    mint_voucher_task.delay(str(template_id), str(user_id))
    return {"status": "queued"}

=== api/v1/wallets.py ===
from app.api.crud_router import create_crud_router
from app.services.wallet import wallet_service
from app.schemas.wallet import WalletCreate, WalletUpdate, WalletOut

router = create_crud_router(
    crud=wallet_service.crud,
    create_schema=WalletCreate,
    update_schema=WalletUpdate,
    out_schema=WalletOut,
    prefix="/wallets",
    tags=["wallets"],
)

=== api/v1/__init__.py ===
from .auth import router as auth
from .users import router as users
from .businesses import router as businesses
from .tokens import router as tokens
from .wallets import router as wallets
from .balances import router as balances
from .point_txs import router as point_txs
from .swap_txs import router as swap_txs
from .voucher_templates import router as voucher_templates
from .voucher_nfts import router as voucher_nfts
from .tasks import router as tasks
from .tx_history import router as history
from .vouchers_my import router as vouchers_my
from .voucher_mint import router as voucher_mint
from .business_rate import router as biz_rate
from .reviews import router as reviews
from .loyalty import router as loyalty
from .token_minting import router as token_minting
=== api/v1/point_txs.py ===
from app.api.crud_router import create_crud_router
from app.services.point_tx import point_tx_service
from app.schemas.point_tx import PointTxCreate, PointTxOut

router = create_crud_router(
    crud=point_tx_service.crud,
    create_schema=PointTxCreate,
    update_schema=PointTxCreate,
    out_schema=PointTxOut,
    prefix="/point_txs",
    tags=["point_txs"],
)

=== api/v1/tokens.py ===
from app.api.crud_router import create_crud_router
from app.services.token import token_service
from app.schemas.token import TokenCreate, TokenUpdate, TokenOut

router = create_crud_router(
    crud=token_service.crud,
    create_schema=TokenCreate,
    update_schema=TokenUpdate,
    out_schema=TokenOut,
    prefix="/tokens",
    tags=["tokens"],
)

=== api/v1/businesses.py ===
from fastapi import APIRouter, Depends, HTTPException
from typing import Annotated
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.business import business_service
from app.schemas.business import BusinessCreate, BusinessUpdate, BusinessOut
from app.api.deps import get_db


router = APIRouter(prefix="/businesses", tags=["businesses"])


@router.post("/", response_model=BusinessOut)
async def create_business(
    payload: BusinessCreate, db: Annotated[AsyncSession, Depends(get_db)]
):
    """
    Onboard a new business:
    1. Create the business record
    2. Generate Solana keypair
    3. Trigger token minting and pool initialization

    The token minting process happens asynchronously via Celery.
    """
    return await business_service.create(db, payload)

=== api/v1/business_rate.py ===
from decimal import Decimal
from uuid import UUID
from fastapi import APIRouter, Depends, status
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.rate import rate_service
from app.api.deps import get_db

router = APIRouter(prefix="/business_rate", tags=["businesses"])

@router.post("/{biz_id}", status_code=status.HTTP_204_NO_CONTENT)
async def set_rate(biz_id: UUID, new_rate: Decimal, db: AsyncSession = Depends(get_db)):
    await rate_service.set_rate(db, biz_id, new_rate)

=== api/v1/business_onboarding.py ===
from fastapi import APIRouter, Depends, BackgroundTasks
from typing import Annotated
from sqlalchemy.ext.asyncio import AsyncSession
from app.services.business import business_service
from app.schemas.business import BusinessCreate, BusinessOut
from app.api.deps import get_db
from app.tasks.business import mint_token_task


router = APIRouter(prefix="/business-onboarding", tags=["business-onboarding"])


@router.post("/", response_model=BusinessOut)
async def onboard_business(
    payload: BusinessCreate, 
    background_tasks: BackgroundTasks,
    db: Annotated[AsyncSession, Depends(get_db)]
):

    # Create the business with its keypair
    business = await business_service.create(db, payload)
    
    # Enqueue the token minting task (this already happens in business_service.create,
    # but for explicitness, we'll add it here too)
    # mint_token_task.delay(str(business.id))
    
    return business

=== api/v1/balances.py ===
from app.api.crud_router import create_crud_router
from app.services.balance import balance_service
from app.schemas.balance import BalanceCreate, BalanceUpdate, BalanceOut

router = create_crud_router(
    crud=balance_service.crud,
    create_schema=BalanceCreate,
    update_schema=BalanceUpdate,
    out_schema=BalanceOut,
    prefix="/balances",
    tags=["balances"],
)

=== api/v1/tx_history.py ===
from fastapi import APIRouter, Depends, Query
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID
from app.api.deps import get_db
from app.services.tx_history import tx_history_service

router = APIRouter(prefix="/history", tags=["history"])

@router.get("/user/{user_id}", response_model=List[dict])
async def user_history(
    user_id: UUID,
    db: AsyncSession = Depends(get_db),
    limit: int = Query(50, ge=1, le=200),
):
    return await tx_history_service.list_user(db, user_id, limit=limit)

=== api/v1/vouchers_my.py ===
from fastapi import APIRouter, Depends
from uuid import UUID
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from app.api.deps import get_db
from app.services.voucher import voucher_service
from app.schemas.voucher import VoucherNFTOut

router = APIRouter(prefix="/vouchers", tags=["vouchers"])

@router.get("/user/{user_id}", response_model=List[VoucherNFTOut])
async def my_vouchers(user_id: UUID, db: AsyncSession = Depends(get_db)):
    return await voucher_service.user_vouchers(db, user_id)
=== api/v1/voucher_nfts.py ===
from app.api.crud_router import create_crud_router
from app.services.voucher_nft import voucher_nft_service
from app.schemas.voucher import VoucherNFTCreate, VoucherNFTUpdate, VoucherNFTOut

router = create_crud_router(
    crud=voucher_nft_service.crud,
    create_schema=VoucherNFTCreate,
    update_schema=VoucherNFTUpdate,
    out_schema=VoucherNFTOut,
    prefix="/voucher_nfts",
    tags=["voucher_nfts"],
)

=== api/v1/loyalty.py ===
import datetime
from uuid import UUID
from decimal import Decimal
from fastapi import APIRouter, Depends, HTTPException, status, Query
from sqlalchemy.ext.asyncio import AsyncSession
from app.api.deps import get_db
from app.models.promotion import PromotionCampaign
from app.services.balance import balance_service
from app.services.business import business_service
from app.services.wallet import wallet_service
from app.services.promotion_campaign import promotion_campaign_service
from app.services.loyalty import LoyaltyService
from app.schemas.base import BaseSchema
from app.schemas.point_tx import PointTxOut
from app.schemas.promotion import PromotionOut

router = APIRouter(prefix="/loyalty", tags=["loyalty"])


class EarnRequest(BaseSchema):
    wallet_pubkey: str
    purchase_amount: Decimal


class RedeemRequest(BaseSchema):
    wallet_pubkey: str
    campaign_id: UUID
    purchase_amount: Decimal


class RedeemResponse(BaseSchema):
    point_tx: PointTxOut
    final_amount: Decimal
    discount: Decimal


@router.post(
    "/business/{biz_id}/earn",
    response_model=PointTxOut,
    status_code=status.HTTP_201_CREATED,
)
async def earn_points(biz_id: UUID, payload: EarnRequest, db: AsyncSession = Depends(get_db)):
    biz = await business_service.read(db, biz_id)
    if not biz:
        raise HTTPException(status_code=404, detail="business not found")
    wallet = await wallet_service.get_by_pubkey(db, payload.wallet_pubkey)
    if not wallet:
        raise HTTPException(status_code=404, detail="wallet not found")

    service = LoyaltyService(db)
    tx = await service.earn_points(
        business=biz, wallet=wallet, purchase_amount=payload.purchase_amount
    )
    await db.commit()
    return tx


@router.post(
    "/business/{biz_id}/redeem",
    response_model=RedeemResponse,
    status_code=status.HTTP_201_CREATED,
)
async def redeem_points(biz_id: UUID, payload: RedeemRequest, db: AsyncSession = Depends(get_db)):
    campaign = await promotion_campaign_service.read(db, payload.campaign_id)
    if not campaign or str(campaign.business_id) != str(biz_id):
        raise HTTPException(status_code=404, detail="campaign not found")
    wallet = await wallet_service.get_by_pubkey(db, payload.wallet_pubkey)
    if not wallet:
        raise HTTPException(status_code=404, detail="wallet not found")

    service = LoyaltyService(db)
    res = await service.redeem_points(
        campaign=campaign, wallet=wallet, purchase_amount=payload.purchase_amount
    )
    await db.commit()
    return res


@router.get("/business/{biz_id}/campaigns", response_model=list[PromotionOut])
async def list_campaigns(
    biz_id: UUID,
    wallet_pubkey: str = Query(...),
    db: AsyncSession = Depends(get_db),
):
    """
    Return active campaigns affordable by user balance.
    """
    wallet = await wallet_service.get_by_pubkey(db, wallet_pubkey)
    if not wallet:
        raise HTTPException(status_code=404, detail="wallet not found")
    biz = await business_service.read(db, biz_id)
    if not biz:
        raise HTTPException(status_code=404, detail="business not found")

    token = biz.loyalty_token
    bal = await balance_service.get_balance(db, wallet, token)
    all_campaigns = await promotion_campaign_service.read_many(
        db,
        filters=[
            PromotionCampaign.business_id == biz_id,
            PromotionCampaign.active_from <= datetime.datetime.now(datetime.UTC),
            PromotionCampaign.active_to >= datetime.datetime.now(datetime.UTC),
        ],
        limit=100,
    )
    return [c for c in all_campaigns if bal >= c.price_points]

=== api/deps.py ===
from app.db.session import get_db

=== api/crud_router.py ===
from uuid import UUID
from pydantic import BaseModel
from fastapi import APIRouter, Depends, HTTPException, Query, status
from typing import Annotated, Type, TypeVar, Union, List
from sqlalchemy.ext.asyncio import AsyncSession

from app.api.deps import get_db
from app.crud.base import CRUDBase
from app.db.base import Base as ORMBase

ModelType = TypeVar("ModelType", bound=ORMBase)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)
OutSchemaType = TypeVar("OutSchemaType", bound=BaseModel)


def create_crud_router(
    *,
    crud: CRUDBase[ModelType, CreateSchemaType, UpdateSchemaType],
    create_schema: Type[CreateSchemaType],
    update_schema: Type[UpdateSchemaType],
    out_schema: Type[OutSchemaType],
    prefix: str,
    tags: List[str]
):
    router = APIRouter(prefix=prefix, tags=tags)

    @router.post("/", response_model=out_schema, status_code=status.HTTP_201_CREATED)
    async def create_item(
        payload: create_schema, db: Annotated[AsyncSession, Depends(get_db)]
    ) -> ModelType:
        return await crud.create(db, payload)

    @router.get("/{item_id}", response_model=out_schema)
    async def read_item(
        item_id: Union[str, UUID], db: Annotated[AsyncSession, Depends(get_db)]
    ) -> ModelType:
        obj = await crud.read(db, item_id)
        if not obj:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"
            )
        return obj

    @router.get("/", response_model=List[out_schema])
    async def read_items(
        db: Annotated[AsyncSession, Depends(get_db)],
        start: int = Query(0, ge=0),
        limit: int = Query(10, ge=1, le=100),
    ) -> List[OutSchemaType]:
        return await crud.read_many(db, start=start, limit=limit)

    @router.patch("/{item_id}", response_model=out_schema)
    async def update_item(
        item_id: Union[str, UUID],
        payload: update_schema,
        db: Annotated[AsyncSession, Depends(get_db)],
    ) -> ModelType:
        obj = await crud.read(db, item_id)
        if not obj:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"
            )
        return await crud.update(db, obj, payload)

    @router.delete("/{item_id}", status_code=status.HTTP_204_NO_CONTENT)
    async def delete_item(
        item_id: Union[str, UUID], db: Annotated[AsyncSession, Depends(get_db)]
    ) -> None:
        obj = await crud.read(db, item_id)
        if not obj:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND, detail="Item not found"
            )
        await crud.delete(db, item_id)

    return router

=== api/__init__.py ===

=== api/ws.py ===
from fastapi import APIRouter, WebSocket, WebSocketDisconnect, status
from uuid import UUID
from app.ws.manager import WSManager
from app.models.transactions import SwapTx
from app.db.session import AsyncSessionLocal

router = APIRouter(prefix="/ws")


@router.websocket("/swap/{swap_id}")
async def swap_ws(ws: WebSocket, swap_id: str):
    """
    Client subscribes right after POST /swap_txs.
    Server streams JSON payloads:
      {"swap_id": "...", "event": "pending|success|failed"}
    """
    # quick existence check
    async with AsyncSessionLocal() as db:
        if not await db.get(SwapTx, UUID(swap_id)):
            await ws.close(code=status.WS_1008_POLICY_VIOLATION)
            return

    mgr = WSManager()
    await mgr.connect(swap_id, ws)

    try:
        while True:
            await ws.receive_text()  # keep-alive ping-pong
    except WebSocketDisconnect:
        await mgr.disconnect(swap_id, ws)

=== api/router.py ===
from fastapi import APIRouter
from app.api.v1 import (
    auth,
    users,
    businesses,
    tokens,
    balances,
    wallets,
    point_txs,
    swap_txs,
    voucher_templates,
    voucher_nfts,
    tasks,
    history,
    vouchers_my,
    voucher_mint,
    biz_rate,
    reviews,
    loyalty,
    business_onboarding,
    token_minting,
)


router = APIRouter()
router.include_router(auth)
router.include_router(users)
router.include_router(businesses)
router.include_router(tokens)
router.include_router(wallets)
router.include_router(balances)
router.include_router(point_txs)
router.include_router(swap_txs)
router.include_router(voucher_templates)
router.include_router(voucher_nfts)
router.include_router(tasks)
router.include_router(history)
router.include_router(vouchers_my)
router.include_router(voucher_mint)
router.include_router(biz_rate)
router.include_router(reviews)
router.include_router(loyalty)
# router.include_router(business_onboarding)
router.include_router(token_minting)
=== alembic/script.py.mako ===
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision: str = ${repr(up_revision)}
down_revision: Union[str, None] = ${repr(down_revision)}
branch_labels: Union[str, Sequence[str], None] = ${repr(branch_labels)}
depends_on: Union[str, Sequence[str], None] = ${repr(depends_on)}


def upgrade() -> None:
    """Upgrade schema."""
    ${upgrades if upgrades else "pass"}


def downgrade() -> None:
    """Downgrade schema."""
    ${downgrades if downgrades else "pass"}

=== alembic/env.py ===
import os
import app.models  # noqa: F401
from pathlib import Path
from dotenv import load_dotenv

root = Path(__file__).parent.parent.parent.parent.parent.parent
load_dotenv(root / ".env")
print(root)


import asyncio
from logging.config import fileConfig
from alembic import context
from sqlalchemy.ext.asyncio import create_async_engine
from sqlalchemy import pool
from app.core.settings import settings
from app.db.base import Base


config = context.config
fileConfig(config.config_file_name)

target_metadata = Base.metadata

down_revision = None

def run_migrations_offline() -> None:
    """
    Migration without connection to DB
    :return:
    """

    url = settings.database_url
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
    with context.begin_transaction():
        context.run_migrations()


async def run_migrations_online() -> None:
    """
    Migrations over asyncio engine
    :return:
    """
    connectable = create_async_engine(
        settings.database_url, future=True, poolclass=pool.NullPool
    )
    async with connectable.connect() as connection:
        await connection.run_sync(
            lambda sync_conn: context.configure(
                connection=sync_conn,
                target_metadata=target_metadata,
                render_as_batch=True,
                # compare_type=True,
                compare_type=(sync_conn.dialect.name != "sqlite"),
            )
        )
        async with connection.begin():
            await connection.run_sync(lambda sync_conn: context.run_migrations())
    await connectable.dispose()


def run() -> None:
    if context.is_offline_mode():
        run_migrations_offline()
    else:
        asyncio.run(run_migrations_online())


run()

=== alembic/versions/0002_owner_pubkey.py ===
# app/alembic/versions/0002_owner_pubkey.py
from alembic import op, context
import sqlalchemy as sa

# revision identifiers, etc.
revision = "0002_owner_pubkey"
down_revision = "0001_initial"
branch_labels = None
depends_on = None

def upgrade() -> None:
    # 1) add the new column (nullable=True so existing rows are OK)
    op.add_column(
        "businesses",
        sa.Column("owner_pubkey", sa.String(length=88), nullable=True),
    )

    # 2) immediately make it non-nullable in a batch context
    with op.batch_alter_table("businesses") as batch_op:
        batch_op.alter_column(
            "owner_pubkey",
            existing_type=sa.String(length=88),
            nullable=False,
        )

def downgrade() -> None:
    # reverse the same way
    bind = op.get_bind()
    dialect = bind.dialect.name

    if dialect == "sqlite":
        with op.batch_alter_table("businesses", reflect=True) as batch_op:
            batch_op.alter_column(
                "owner_pubkey",
                existing_type=sa.String(length=88),
                nullable=True,
            )
    else:
        op.alter_column(
            "businesses",
            "owner_pubkey",
            existing_type=sa.String(length=88),
            nullable=True,
        )

=== alembic/versions/0001_initial.py ===
"""Initial combined schema

Revision ID: 0001_initial
Revises:
Create Date: 2025-05-13 12:00:00.000000
"""

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql

# revision identifiers, used by Alembic.
revision = "0001_initial"
down_revision = None
branch_labels = None
depends_on = None


def upgrade() -> None:
    # --- ENUMS ---
    task_status = sa.Enum("PENDING", "SUCCESS", "FAILED", "RETRY", name="task_status_enum")
    tx_type     = sa.Enum("EARN", "REDEEM", "SWAP_IN", "SWAP_OUT", name="tx_type_enum")
    tx_status   = sa.Enum("PENDING", "SUCCESS", "FAILED", name="tx_status_enum")
    voucher_st  = sa.Enum("ACTIVE", "REDEEMED", "EXPIRED", name="voucher_status_enum")
    promo_type  = sa.Enum("DISCOUNT", name="promo_type_enum")

    for enum in (task_status, tx_type, tx_status, voucher_st, promo_type):
        enum.create(op.get_bind(), checkfirst=True)

    # --- businesses ---
    op.create_table(
        "businesses",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("name", sa.String(128), nullable=False, unique=True),
        sa.Column("slug", sa.String(64), nullable=False),
        sa.Column("logo_url", sa.String(512), nullable=True),
        sa.Column("owner_email", sa.String(320), nullable=False),
        sa.Column("description", sa.String(512), nullable=False),
        sa.Column("country", sa.String(64), nullable=False),
        sa.Column("city", sa.String(128), nullable=False),
        sa.Column("address", sa.String(128), nullable=False),
        sa.Column("zip_code", sa.String(12), nullable=False),
        sa.Column("owner_privkey", sa.String(88), nullable=False),
        sa.Column("rate_loyl", sa.Numeric(18, 6), nullable=False, comment="Rate branded token to LOYL"),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.CheckConstraint("length(slug) >= 3", name="check_slug_min_length"),
    )
    op.create_index("ix_businesses_slug", "businesses", ["slug"], unique=True)
    op.create_index("ix_businesses_owner_email", "businesses", ["owner_email"], unique=False)

    # --- celery_task_logs ---
    op.create_table(
        "celery_task_logs",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("task_id", sa.String(50), nullable=False, unique=True),
        sa.Column("queue", sa.String(32), nullable=False),
        sa.Column("status", sa.Enum(name="task_status_enum"), nullable=False),
        sa.Column("payload", sa.JSON(), nullable=True),
        sa.Column("result", sa.String(32), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
    )
    op.create_index("ix_celery_task_logs_queue", "celery_task_logs", ["queue"], unique=False)
    op.create_index("ix_celery_task_logs_status", "celery_task_logs", ["status"], unique=False)

    # --- users ---
    op.create_table(
        "users",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("privy_id", sa.String(64), nullable=False, unique=True),
        sa.Column("email", sa.String(320), nullable=True, unique=True),
        sa.Column("phone", sa.String(32), nullable=True, unique=True),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
    )
    op.create_index("ix_users_privy_id", "users", ["privy_id"], unique=True)

    # --- tokens ---
    op.create_table(
        "tokens",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("mint", sa.String(64), nullable=False, unique=True),
        sa.Column("symbol", sa.String(6), nullable=False, unique=True),
        sa.Column("coin_logo_url", sa.String(512), nullable=True),
        sa.Column("decimals", sa.Integer(), nullable=False),
        sa.Column("business_id", postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column("settlement_token", sa.Boolean(), nullable=False, server_default=sa.text("false")),
        sa.Column("rate_loyl", sa.Numeric(18, 6), nullable=False),
        sa.Column("min_rate", sa.Numeric(18, 6), nullable=True),
        sa.Column("max_rate", sa.Numeric(18, 6), nullable=True),
        sa.Column("total_supply", sa.BigInteger(), nullable=False, comment="Current totalSupply (base-units)"),
        sa.CheckConstraint("decimals BETWEEN 0 AND 9", name="check_decimals_range"),
        sa.CheckConstraint("min_rate <= max_rate", name="check_min_le_max_rate"),
        sa.ForeignKeyConstraint(["business_id"], ["businesses.id"], ondelete="SET NULL"),
    )
    op.create_index("ix_tokens_mint", "tokens", ["mint"], unique=True)
    # NOTE: partial index on settlement_token only supported in Postgres
    op.create_index("uq_single_loyl", "tokens", ["settlement_token"], unique=True, postgresql_where=sa.text("settlement_token IS TRUE"))

    # --- voucher_templates ---
    op.create_table(
        "voucher_templates",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("business_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("name", sa.String(128), nullable=False),
        sa.Column("description", sa.String(320), nullable=True),
        sa.Column("image_url", sa.String(320), nullable=True),
        sa.Column("price_points", sa.BigInteger(), nullable=False),
        sa.Column("supply", sa.Integer(), nullable=False),
        sa.Column("expires_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("collection_mint", sa.String(64), nullable=True, unique=True),
        sa.ForeignKeyConstraint(["business_id"], ["businesses.id"], ondelete="CASCADE"),
    )

    # --- wallets ---
    op.create_table(
        "wallets",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("user_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("pubkey", sa.String(44), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="CASCADE"),
        sa.UniqueConstraint("user_id", "pubkey", name="uq_user_pubkey"),
    )
    op.create_index("ix_wallets_pubkey", "wallets", ["pubkey"], unique=True)

    # --- balances ---
    op.create_table(
        "balances",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("wallet_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("token_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("amount", sa.BigInteger(), nullable=False),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.Column("updated_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.ForeignKeyConstraint(["wallet_id"], ["wallets.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["token_id"], ["tokens.id"], ondelete="CASCADE"),
        sa.UniqueConstraint("wallet_id", "token_id", name="uq_wallet_token"),
    )

    # --- point_txs ---
    op.create_table(
        "point_txs",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("wallet_id", postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column("token_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("tx_type", sa.Enum(name="tx_type_enum"), nullable=False),
        sa.Column("amount", sa.BigInteger(), nullable=False),
        sa.Column("fee_bps", sa.Integer(), nullable=True),
        sa.Column("sol_sig", sa.String(128), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.CheckConstraint("fee_bps BETWEEN 0 AND 10000", name="check_fee_bps_range"),
        sa.ForeignKeyConstraint(["wallet_id"], ["wallets.id"], ondelete="SET NULL"),
        sa.ForeignKeyConstraint(["token_id"], ["tokens.id"]),
    )
    op.create_index("ix_point_txs_wallet_id", "point_txs", ["wallet_id"], unique=False)

    # --- swap_txs ---
    op.create_table(
        "swap_txs",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("user_id", postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column("from_token_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("to_token_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("from_amount", sa.BigInteger(), nullable=False),
        sa.Column("to_amount", sa.BigInteger(), nullable=False),
        sa.Column("fee_bps", sa.Integer(), nullable=False),
        sa.Column("sol_sig", sa.String(128), nullable=True),
        sa.Column("sol_sig_redeem", sa.String(128), nullable=True),
        sa.Column("status", sa.Enum(name="tx_status_enum"), nullable=False, server_default="PENDING"),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.CheckConstraint("from_amount > 0 AND to_amount > 0", name="check_swap_amounts_positive"),
        sa.ForeignKeyConstraint(["from_token_id"], ["tokens.id"]),
        sa.ForeignKeyConstraint(["to_token_id"], ["tokens.id"]),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="SET NULL"),
    )
    op.create_index("ix_swap_txs_user_id", "swap_txs", ["user_id"], unique=False)

    # --- voucher_nfts ---
    op.create_table(
        "voucher_nfts",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("template_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("user_id", postgresql.UUID(as_uuid=True), nullable=True),
        sa.Column("asset_id", sa.String(128), nullable=False),
        sa.Column("status", sa.Enum(name="voucher_status_enum"), nullable=False),
        sa.Column("redeemed_at", sa.DateTime(timezone=True), nullable=True),
        sa.Column("created_at", sa.DateTime(timezone=True), server_default=sa.text("CURRENT_TIMESTAMP"), nullable=False),
        sa.ForeignKeyConstraint(["template_id"], ["voucher_templates.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="SET NULL"),
        sa.UniqueConstraint("template_id", "asset_id", name="uq_template_asset"),
    )

    # --- promotion_campaigns ---
    op.create_table(
        "promotion_campaigns",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("business_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("name", sa.String(128), nullable=False),
        sa.Column("promo_type", sa.Enum(name="promo_type_enum"), nullable=False),
        sa.Column("price_points", sa.BigInteger(), nullable=False),
        sa.Column("discount_pct", sa.Numeric(5, 2), nullable=False),
        sa.Column("active_from", sa.DateTime(timezone=True), nullable=True),
        sa.Column("active_to", sa.DateTime(timezone=True), nullable=True),
        sa.ForeignKeyConstraint(["business_id"], ["businesses.id"], ondelete="CASCADE"),
        sa.UniqueConstraint("business_id", "name", name="uq_campaign_name_biz"),
        sa.CheckConstraint("price_points > 0", name="check_positive_price"),
        sa.CheckConstraint("discount_pct BETWEEN 1 AND 100", name="check_pct_range"),
    )

    # --- token_pools ---
    op.create_table(
        "token_pools",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("token_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("provider", sa.String(16), nullable=False, server_default="platform"),
        sa.Column("init_tx", sa.String(88), nullable=False),
        sa.Column("balance_token", sa.BigInteger(), nullable=False),
        sa.Column("balance_loyl", sa.BigInteger(), nullable=False),
        sa.CheckConstraint("balance_token >= 0 AND balance_loyl >= 0", name="check_pool_nonnegative"),
        sa.UniqueConstraint("token_id", name="uq_token_pool"),
        sa.ForeignKeyConstraint(["token_id"], ["tokens.id"], ondelete="CASCADE"),
    )

    # --- voucher_mint_txs ---
    op.create_table(
        "voucher_mint_txs",
        sa.Column("id", postgresql.UUID(as_uuid=True), primary_key=True, nullable=False),
        sa.Column("template_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("user_id", postgresql.UUID(as_uuid=True), nullable=False),
        sa.Column("asset_id", sa.String(128), nullable=True),
        sa.Column("status", sa.Enum(name="tx_status_enum"), nullable=False),
        sa.ForeignKeyConstraint(["template_id"], ["voucher_templates.id"], ondelete="CASCADE"),
        sa.ForeignKeyConstraint(["user_id"], ["users.id"], ondelete="CASCADE"),
    )


def downgrade() -> None:
    # drop tables in reverse order
    op.drop_table("voucher_mint_txs")
    op.drop_table("token_pools")
    op.drop_table("promotion_campaigns")
    op.drop_table("voucher_nfts")
    op.drop_table("swap_txs")
    op.drop_table("point_txs")
    op.drop_table("balances")
    op.drop_table("wallets")
    op.drop_table("voucher_templates")
    op.drop_table("tokens")
    op.drop_table("users")
    op.drop_table("celery_task_logs")
    op.drop_table("businesses")

    # drop enums
    for enum in [
        "promo_type_enum",
        "voucher_status_enum",
        "tx_status_enum",
        "tx_type_enum",
        "task_status_enum",
    ]:
        op.execute(f"DROP TYPE IF EXISTS {enum}")

=== alembic/__init__.py ===

=== alembic/README ===
Generic single-database configuration.
=== main.py ===
from typing import Union
from pathlib import Path
from fastapi import FastAPI, APIRouter, Depends, HTTPException
from fastapi.security import HTTPBearer
from app.core.settings import settings
from app.core.security import verify_privy_token
from app.api.v1.auth import router as auth_router
from app.api.router import router as v1_router
from app.api.ws import router as ws_router
from app.services.exchange_client import ExchangeClient

bearer = HTTPBearer(auto_error=False)


def current_user(creds=Depends(bearer)):
    if not creds:
        raise HTTPException(status_code=401)
    return verify_privy_token(creds.credentials)


app = FastAPI(**settings.fastapi_kwargs)

# 1) public endpoints ver 1
public_v1 = APIRouter(prefix="/api/v1")
public_v1.include_router(auth_router)  # только /auth
app.include_router(public_v1)


# 2) protected endpoints ver 1
protected_v1 = APIRouter(prefix="/api/v1", dependencies=[Depends(current_user)])
protected_v1.include_router(v1_router)  # users, businesses, tokens и т.д.
app.include_router(protected_v1)

app.include_router(ws_router)


# initializationn of Anchor client
root = Path(__file__).parent.parent.parent
print(f"==================== {root} ====================")
idl_path = root / "app" / "anchor" / "target" / "idl" / "exchange.json"

# print(idl_path.exists(), idl_path.read_text()[:200])

exchange_client = ExchangeClient(
    rpc_url=settings.SOLANA_RPC_URL,
    payer_keypair=settings.treasury_kp,
    program_id=settings.exchange_program_pk,
    idl_path=idl_path,
)


@app.get("/")
def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}

=== print_all.sh ===
find . \
  -type f ! -name 'all.txt' ! -name '*.pyc' \
  -exec sh -c '
    file="$1"
    rel="${file#./}"
    printf "\n=== %s ===\n" "$rel"
    cat "$file"
  ' _ {} \; > all.txt
=== services/user.py ===
from sqlalchemy import select
from pydantic import EmailStr
from app.crud.base import CRUDBase
from app.models.user import User
from app.schemas.user import UserCreate, UserUpdate
from app.services.base import BaseService

crud_user = CRUDBase[User, UserCreate, UserUpdate](User)


class UserService(BaseService[User, UserCreate, UserUpdate]):
    async def create_or_get(
        self, db, *, privy_id: str, email: EmailStr, phone: str
    ) -> User:
        """
        Return existing user by privy_id or create a new one.
        """
        q = select(User).where(User.privy_id == privy_id)
        res = await db.execute(q)
        user = res.scalar_one_or_none()
        if user:
            return user
        payload = UserCreate(privy_id=privy_id, email=email, phone=phone)
        return await self.create(db, payload)

    async def get_by_privy(self, db, privy_id: str) -> User | None:
        """
        Fetch a user by privy_id, or return None if not found.
        """
        q = select(User).where(User.privy_id == privy_id)
        res = await db.execute(q)
        return res.scalar_one_or_none()


user_service = UserService(crud_user)

=== services/task.py ===
from app.services.base import BaseService
from app.crud.base import CRUDBase
from app.models.tasks import CeleryTaskLog
from app.schemas.tasks import CeleryTaskLogCreate, CeleryTaskLogUpdate

crud_celery_task = CRUDBase[CeleryTaskLog, CeleryTaskLogCreate, CeleryTaskLogUpdate](
    CeleryTaskLog
)


class CeleryTaskService(
    BaseService[CeleryTaskLog, CeleryTaskLogCreate, CeleryTaskLogUpdate]
):
    pass


celery_task_service = CeleryTaskService(crud_celery_task)

=== services/transfer_exec.py ===
import asyncio, base58, base64
from base64 import b64encode
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.transaction import Transaction
from solders.signature import Signature
from solders.instruction import Instruction, AccountMeta
from solders.message import Message
from solana.rpc.async_api import AsyncClient
from solana.rpc.types import TxOpts
from solana.rpc.commitment import Confirmed
from spl.token.constants import TOKEN_2022_PROGRAM_ID
from spl.token.instructions import get_associated_token_address

from app.services.privy_client import PrivyClient
from app.core.settings import settings


def build_transfer_ix(
    mint: Pubkey,
    src_owner: Pubkey,
    dst_owner: Pubkey,
    amount: int,
) -> Instruction:
    """
    Build a raw SPL-2022 transfer instruction.
    Instruction code = 3, amount in little-endian U64.
    """
    src_ata = get_associated_token_address(mint, src_owner)
    dst_ata = get_associated_token_address(mint, dst_owner)
    data = bytes([3]) + amount.to_bytes(8, "little")
    accounts = [
        AccountMeta(src_ata, is_signer=False, is_writable=True),
        AccountMeta(dst_ata, is_signer=False, is_writable=True),
        AccountMeta(src_owner, is_signer=True, is_writable=False),
    ]
    return Instruction(TOKEN_2022_PROGRAM_ID, accounts, data)


async def _submit_transfer(
    *,
    mint: str,
    sender: str,
    recipient: str,
    amount: int,
    sender_kp: Keypair | None,
    sign_with_privy: bool,
) -> str:
    """
    Create, sign (either locally or via Privy), send transaction and return tx signature.
    """
    async with AsyncClient(settings.SOLANA_RPC_URL) as rpc:
        # fetch latest blockhash
        bh = (await rpc.get_latest_blockhash()).value.blockhash

        # prepare instruction and message
        mint_pk = Pubkey.from_string(mint)
        sender_pk = Pubkey.from_string(sender)
        dest_pk = Pubkey.from_string(recipient)

        msg = Message(
            instructions=[build_transfer_ix(mint_pk, sender_pk, dest_pk, amount)],
            payer=sender_pk,
            recent_blockhash=bh,
        )

        # --- Privy signing path ---------------------------------------------
        if sign_with_privy:
            # request full signed transaction from Privy
            privy = PrivyClient(settings.PRIVY_APP_ID, settings.PRIVY_API_KEY)
            tx_b64 = b64encode(bytes(msg)).decode()
            signed_b64 = await privy.sign_transaction(sender, tx_b64)
            raw_tx = base64.b64decode(signed_b64)
            # forward signed tx to RPC
            resp = await rpc.send_raw_transaction(
                raw_tx,
                opts=TxOpts(skip_preflight=False, preflight_commitment=Confirmed),
            )
            return str(resp.value)

        # --- Local Keypair signing path -------------------------------------
        if sender_kp:
            # sign message locally
            sig = sender_kp.sign_message(bytes(msg))
            tx = Transaction.populate(msg)
            tx.signatures = [sig]
            # send signed transaction
            resp = await rpc.send_raw_transaction(
                bytes(tx),
                opts=TxOpts(skip_preflight=False, preflight_commitment=Confirmed),
            )
            return str(resp.value)

        # --- Error if no signing method provided ----------------------------
        raise ValueError("No signing method provided for transfer")


# Blocking wrappers for Celery tasks

def earn_token(mint: str, user_pubkey: str, business_kp_b58: str, amount: int) -> str:
    """
    Business → User: local keypair signs and submits.
    """
    kp = Keypair.from_bytes(base58.b58decode(business_kp_b58))
    return asyncio.run(
        _submit_transfer(
            mint=mint,
            sender=str(kp.pubkey()),
            recipient=user_pubkey,
            amount=amount,
            sender_kp=kp,
            sign_with_privy=False,
        )
    )


def redeem_token(mint: str, user_pubkey: str, business_pubkey: str, amount: int) -> str:
    """
    User → Business: transaction signed via Privy.
    """
    return asyncio.run(
        _submit_transfer(
            mint=mint,
            sender=user_pubkey,
            recipient=business_pubkey,
            amount=amount,
            sender_kp=None,
            sign_with_privy=True,
        )
    )

=== services/token.py ===
from app.services.base import BaseService
from app.crud.base import CRUDBase
from app.models.token import Token
from app.schemas.token import TokenCreate, TokenUpdate

crud_token = CRUDBase[Token, TokenCreate, TokenUpdate](Token)


class TokenService(BaseService[Token, TokenCreate, TokenUpdate]):
    pass


token_service = TokenService(crud_token)

=== services/voucher_nft.py ===
from app.services.base import BaseService
from app.crud.base import CRUDBase
from app.models.voucher import VoucherNFT
from app.schemas.voucher import VoucherNFTCreate, VoucherNFTUpdate

crud_voucher_nft = CRUDBase[VoucherNFT, VoucherNFTCreate, VoucherNFTUpdate](VoucherNFT)


class VoucherNFTService(BaseService[VoucherNFT, VoucherNFTCreate, VoucherNFTUpdate]):
    pass


voucher_nft_service = VoucherNFTService(crud_voucher_nft)

=== services/celery_wrapper.py ===
"""Thread-safe logging decorator for Celery tasks (async-db aware)."""
from __future__ import annotations
import asyncio
from functools import wraps
from typing import Any, Callable, ParamSpec, TypeVar
from celery import Task
from sqlalchemy.ext.asyncio import AsyncSession
from app.db.session import AsyncSessionLocal
from app.models import CeleryTaskLog, TaskStatus

_R = TypeVar("_R")
_P = ParamSpec("_P")


def log_task(fn: Callable[_P, _R]) -> Callable[_P, _R]:
    """Wrap a Celery task and persist run metadata in `celery_task_logs` table."""

    @wraps(fn)
    def _inner(self: Task, *args: _P.args, **kwargs: _P.kwargs) -> _R:  # type: ignore[name-defined]
        async def _log(result: str | None, status: TaskStatus) -> None:
            async with AsyncSessionLocal() as db:  # type: AsyncSession
                db.add(
                    CeleryTaskLog(
                        task_id=self.request.id,
                        queue=self.request.delivery_info["routing_key"],
                        status=status,
                        payload={"args": args, "kwargs": kwargs},
                        result=(result or "")[:88],
                    )
                )
                await db.commit()

        try:
            result: Any = fn(self, *args, **kwargs)  # task body (sync)
            asyncio.run(_log(str(result), TaskStatus.SUCCESS))
            return result  # type: ignore[return-value]
        except Exception as exc:  # noqa: BLE001
            asyncio.run(_log(None, TaskStatus.FAILED))
            raise exc

    return _inner

=== services/rate.py ===
from decimal import Decimal
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import Business

class RateService:
    async def set_rate(self, db: AsyncSession, biz_id: UUID, new_rate: Decimal):
        biz = await db.get(Business, biz_id)
        if not biz:
            raise ValueError("business not found")
        biz.rate_loyl = new_rate
        biz.loyalty_token.rate_loyl = new_rate
        await db.commit()

rate_service = RateService()

=== services/voucher_template.py ===
from app.services.base import BaseService
from app.crud.base import CRUDBase
from app.models.voucher import VoucherTemplate
from app.schemas.voucher import VoucherTemplateCreate, VoucherTemplateUpdate

crud_voucher_template = CRUDBase[
    VoucherTemplate, VoucherTemplateCreate, VoucherTemplateUpdate
](VoucherTemplate)


class VoucherTemplateService(
    BaseService[VoucherTemplate, VoucherTemplateCreate, VoucherTemplateUpdate]
):
    pass


voucher_template_service = VoucherTemplateService(crud_voucher_template)

=== services/swap_tx.py ===
from app.services.base import BaseService
from app.crud.base import CRUDBase
from app.models.transactions import SwapTx
from app.schemas.swap_tx import SwapTxCreate, SwapTxOut  # Out as Update
from sqlalchemy.ext.asyncio import AsyncSession
from app.tasks.onchain import swap_task


crud_swap_tx = CRUDBase[SwapTx, SwapTxCreate, SwapTxCreate](SwapTx)


class SwapTxService(BaseService[SwapTx, SwapTxCreate, SwapTxCreate]):
    async def create(self, db: AsyncSession, payload: SwapTxCreate) -> SwapTx:
        record = await super().create(db, payload)
        # Fire-and-forget on-chain execution
        swap_task.delay(str(record.id))
        return record


swap_tx_service = SwapTxService(crud_swap_tx)

=== services/point_tx.py ===
from app.services.base import BaseService
from app.crud.base import CRUDBase
from app.models.transactions import PointTx
from app.schemas.point_tx import PointTxCreate, PointTxOut  # use Out as Update

crud_point_tx = CRUDBase[PointTx, PointTxCreate, PointTxCreate](PointTx)


class PointTxService(BaseService[PointTx, PointTxCreate, PointTxCreate]):
    pass


point_tx_service = PointTxService(crud_point_tx)

=== services/__init__.py ===

=== services/review.py ===
from uuid import UUID
from decimal import Decimal
from typing import List
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, func
from app.crud.base import CRUDBase
from app.models import BusinessReview
from app.schemas.review import ReviewCreate
from app.services.base import BaseService


# crud object for BusinessReview: uses the same schema for create and update
crud_review = CRUDBase[BusinessReview, ReviewCreate, ReviewCreate](BusinessReview)


class ReviewService(BaseService[BusinessReview, ReviewCreate, ReviewCreate]):
    """
    Service layer for managing BusinessReview entities.
    """

    async def create(self, db: AsyncSession, payload: ReviewCreate) -> BusinessReview:
        """
        Create a new review for a business.

        Raises:
            ValueError: if payload data is invalid (e.g., foreign keys).
        """
        # Let BaseService/CRUD handle the insertion and commit.
        return await super().create(db, payload)

    async def get_reviews_for_business(
        self,
        db: AsyncSession,
        business_id: UUID,
        start: int = 0,
        limit: int = 10,
    ) -> List[BusinessReview]:
        """
        Fetch a paginated list of reviews for a given business,
        ordered by newest first.
        """
        stmt = (
            select(BusinessReview)
            .where(BusinessReview.business_id == business_id)
            .order_by(BusinessReview.created_at.desc())
            .offset(start)
            .limit(limit)
        )
        result = await db.execute(stmt)
        return list(result.scalars().all())

    async def get_average_rating(
        self,
        db: AsyncSession,
        business_id: UUID,
    ) -> Decimal:
        """
        Compute and return the average score for a business.
        Returns Decimal('0') if no reviews exist.
        """
        stmt = select(func.avg(BusinessReview.score)).where(
            BusinessReview.business_id == business_id
        )
        result = await db.execute(stmt)
        avg = result.scalar_one_or_none()
        return avg or Decimal("0.00")


# Export a singleton instance
review_service = ReviewService(crud_review)

=== services/token_mint.py ===
from __future__ import annotations
import asyncio, base58
from pathlib import Path
from solders.pubkey import Pubkey
from solders.keypair import Keypair
from solana.rpc.async_api import AsyncClient
from anchorpy import Provider, Wallet, Idl, Program
from sqlalchemy.ext.asyncio import AsyncSession
from app.core.settings import settings
from app.db.session import AsyncSessionLocal
from app.models import Business, Token
from app.services.exchange_client import ExchangeClient
from app.services.pool import PoolService

# --- Constants & cached IDL load ----------------------------------------
# The path to the IDL for loyalty_token
BASE_DIR = Path(__file__).resolve().parent
print(f"==================== {BASE_DIR} ====================")
IDL_PATH = (BASE_DIR / settings.LOYL_IDL_PATH).resolve()

_IDL: Idl
try:
    _IDL = Idl.from_json(IDL_PATH.read_text())
except Exception as e:
    raise RuntimeError(f"Failed to load IDL at {IDL_PATH}: {e}")

LOYALTY_PROGRAM_ID = Pubkey.from_string(settings.LOYL_TOKEN_PROGRAM_ID)


# --- Core mint & record logic ------------------------------------------

async def _mint_and_record_async(business_id: str) -> None:
    """
    Creates a branded loyalty token for a business and initializes a liquidity pool:
    1) Retrieve the business and its owner's keypair
    2) Create the branded loyalty token via the Anchor RPC createLoyaltyMint
    3) Derive the PDA (Program Derived Address) for the mint
    4) Save the token record to the database
    5) Bootstrap the liquidity pool via ExchangeClient + PoolService
    """
    # 1) We open a session
    async with AsyncSessionLocal() as db:  # type: AsyncSession
        biz: Business | None = await db.get(Business, business_id)
        if biz is None:
            raise ValueError(f"Business {business_id} not found")

        # Decoding the owner's key
        owner_kp = Keypair.from_bytes(base58.b58decode(biz.owner_privkey))

        # 2) Creating a Solana RPC client
        async with AsyncClient(settings.SOLANA_RPC_URL) as rpc_client:
            # Setting up AnchorPy Provider + Program
            provider = Provider(rpc_client, Wallet(owner_kp))
            program = Program(_IDL, LOYALTY_PROGRAM_ID, provider)

            decimals = 2
            initial_supply = 1_000_000 * 10**decimals

            # Calling the on-chain method
            tx_sig = await program.rpc["createLoyaltyMint"](
                decimals,
                int(biz.rate_loyl * 10**6),  # fix-point 6 digits
                initial_supply,
                ctx={
                    "accounts": {
                        "authority": owner_kp.pubkey(),
                        "systemProgram": program.program.account["System"].program_id,
                    },
                    "signers": [owner_kp],
                },
            )

            # 3) PDA mint derivation
            mint_pda, _ = Pubkey.find_program_address(
                [b"mint", bytes(owner_kp.pubkey())],
                LOYALTY_PROGRAM_ID,
            )

        # 4) Saving the Token in the DB
        db_token = Token(
            mint=str(mint_pda),
            symbol=biz.slug.upper()[:6],
            business_id=biz.id,
            settlement_token=False,
            rate_loyl=biz.rate_loyl,
            decimals=decimals,
            min_rate=None,
            max_rate=None,
            total_supply=initial_supply,
        )
        db.add(db_token)
        await db.commit()
        await db.refresh(db_token)

        # 5) We initialize the liquidity pool.
        anchor_client = ExchangeClient(
            rpc_url=settings.SOLANA_RPC_URL,
            payer_keypair=settings.treasury_kp,
            program_id=settings.exchange_program_pk,
            idl_path=settings.root / "anchor/target/idl/exchange.json",
        )
        pool_service = PoolService(db, anchor_client)
        await pool_service.bootstrap_pool(db_token)
        await db.commit()


def mint_and_record(business_id: str) -> None:
    """
    Synchronous wrapper for Celery: runs the async token minting process.
    
    Args:
        business_id: UUID of the business to mint tokens for
        
    Raises:
        RuntimeError: If any step in the token minting process fails
    """
    try:
        asyncio.run(_mint_and_record_async(business_id))
    except Exception as err:
        # Log the error with more details
        import logging
        logging.error(f"Token minting failed for business {business_id}: {err}", exc_info=True)
        raise RuntimeError(f"mint_and_record failed for {business_id}: {err}") from err

=== services/privy_client.py ===
from __future__ import annotations
import httpx, base64, hmac, hashlib
from typing import Any
from pydantic import BaseModel


class PrivyUser(BaseModel):
    id: str
    embedded_wallet: str | None = None
    email: str | None = None
    phone: str | None = None


class PrivyClient:
    """Thin async wrapper around Privy REST v1."""

    def __init__(self, app_id: str, api_key: str, cluster: str = "testnet"):
        self.app_id, self.api_key, self.cluster = app_id, api_key, cluster
        self.base = f"https://auth.privy.io/api/v1/apps/{app_id}"
        self._auth = httpx.BasicAuth(app_id, api_key)
        self._hdr = {"privy-app-id": app_id}

    # ---------- helpers ----------
    async def _req(self, method: str, url: str, **kw) -> httpx.Response:
        kw.setdefault("auth", self._auth)
        kw.setdefault("headers", self._hdr)
        async with httpx.AsyncClient(timeout=20) as c:
            r = await c.request(method, url, **kw)
        r.raise_for_status()
        return r

    # ---------- public API ----------
    async def exchange_code(self, code: str) -> str:
        r = await self._req("POST", f"{self.base}/auth/exchange-code", json={"code": code})
        return r.json()["userId"]

    async def get_user(self, privy_id: str) -> PrivyUser:
        r = await self._req("GET", f"{self.base}/users/{privy_id}")
        d: dict[str, Any] = r.json()
        wallets = d.get("wallets", {}).get("solana", [])
        embedded = wallets[0]["address"] if wallets else None
        return PrivyUser(id=d["id"], embedded_wallet=embedded, email=d.get("email"), phone=d.get("phone"))

    async def create_wallets(self, privy_id: str) -> str:
        payload = {"createSolanaWallet": True, "createEthereumWallet": False, "cluster": self.cluster}
        r = await self._req("POST", f"{self.base}/users/{privy_id}/wallets", json=payload)
        return r.json()["wallets"]["solana"][0]["address"]

    async def sign_transaction(self, wallet_address: str, tx_b64: str) -> str:
        """Returns full signed transaction as base64 string."""
        payload = {
            "method": "signTransaction",
            "params": {"transaction": tx_b64, "encoding": "base64", "cluster": self.cluster},
        }
        r = await self._req("POST", f"{self.base}/wallets/{wallet_address}/rpc", json=payload)
        return r.json()["result"]["signedTransaction"]  # full tx b64


def verify_sig(sig: str | None, body: bytes, secret: str) -> bool:
    if not sig:
        return False
    mac = hmac.new(secret.encode(), body, hashlib.sha256).digest()
    return hmac.compare_digest(base64.b64decode(sig), mac)

=== services/bubblegum.py ===
"""
Skeletal wrapper around Bubblegum mints – for MVP minting off-chain,
returning dummy asset_id (uuid4) and saving to db.
"""
import uuid
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import VoucherTemplate, VoucherNFT, VoucherStatus

class BubblegumMinter:
    async def mint(
        self, db: AsyncSession, template: VoucherTemplate, user_id: UUID
    ) -> VoucherNFT:
        asset_id = str(uuid.uuid4())  # in real life will be – hash from on-chain asset
        nft = VoucherNFT(
            template_id=template.id,
            user_id=user_id,
            asset_id=asset_id,
            status=VoucherStatus.ACTIVE,
            redeemed_at=None,
        )
        db.add(nft)
        await db.commit()
        await db.refresh(nft)
        return nft

bubblegum_minter = BubblegumMinter()

=== services/business.py ===
import base58
from solders.keypair import Keypair
from app.services.base import BaseService
from app.crud.base import CRUDBase
from app.models.business import Business
from app.schemas.business import BusinessCreate


crud_business = CRUDBase[Business, BusinessCreate, BusinessCreate](Business)

class BusinessService(BaseService[Business, BusinessCreate, BusinessCreate]):
    async def create(self, db, payload: BusinessCreate) -> Business:
        # 1) generate new Solana keypair
        kp = Keypair()  # correct way to get a fresh keypair :contentReference[oaicite:0]{index=0}
        priv_bytes = kp.secret()  # returns the 64-byte secret key :contentReference[oaicite:1]{index=1}
        pubkey_str = str(kp.pubkey())  # the associated public key

        # 2) encode for storage
        priv_b58 = base58.b58encode(priv_bytes).decode("utf-8")

        # 3) assemble the ORM object
        biz = Business(
            **payload.model_dump(),
            owner_privkey=priv_b58,
            owner_pubkey=pubkey_str,
        )
        db.add(biz)
        await db.commit()
        await db.refresh(biz)

        # 4) enqueue your existing mint/pool bootstrap
        from celery.app.task import Task
        from app.tasks.business import mint_token_task
        mint_token_task: Task
        mint_token_task.delay(str(biz.id))

        return biz

business_service = BusinessService(crud_business)

=== services/pubsub.py ===
import json
from redis import asyncio as aioredis
from app.core.settings import settings

async def publish(channel: str, message: dict):
    r = aioredis.from_url(settings.CELERY_BROKER, encoding="utf-8", decode_responses=True)
    await r.publish(channel, json.dumps(message))
=== services/exchange_client.py ===
from anchorpy import Program, Wallet, Provider, Idl
from solana.rpc.async_api import AsyncClient
from solders.keypair import Keypair
from solders.pubkey import Pubkey
from solders.system_program import ID as SYS_PROGRAM_ID
from spl.token.constants import TOKEN_PROGRAM_ID
from pathlib import Path
from app.core.settings import settings


class ExchangeClient:
    def __init__(
        self,
        rpc_url: str,
        payer_keypair: Keypair,  #  treasury
        program_id: Pubkey,
        idl_path: Path,
    ):
        self.treasury_kp = payer_keypair  # save for later calls
        client = AsyncClient(rpc_url)
        provider = Provider(client, Wallet(self.treasury_kp))
        idl = Idl.from_json(idl_path.read_text())
        self.program = Program(idl, program_id, provider)

    async def init_pool(
        self,
        loyalty_mint: str,  # string of mint-addr SPL-token of business
        deposit_token: int,
        deposit_loyl: int,
        business_signer: Keypair,  # business owner keypair
    ) -> str:
        # converting str to Pubkey
        mint_pubkey = Pubkey.from_string(loyalty_mint)
        # sys_pubkey = Pubkey.from_string(str(SYS_PROGRAM_ID))
        # tok_pubkey = Pubkey.from_string(str(TOKEN_PROGRAM_ID))

        # finding PDA of pool
        pool_pda, _ = Pubkey.find_program_address(
            seeds=[b"pool", bytes(mint_pubkey)],
            program_id=self.program.program_id,
        )

        # calling Anchor-progs
        tx_sig: str = await self.program.rpc["initPool"](
            deposit_token,
            deposit_loyl,
            ctx={
                "accounts": {
                    "pool": pool_pda,
                    "loyaltyMint": mint_pubkey,
                    "businessAuthority": business_signer.pubkey(),
                    "platformAuthority": self.treasury_kp.pubkey(),
                    "tokenProgram": TOKEN_PROGRAM_ID,
                    "systemProgram": SYS_PROGRAM_ID,
                },
                "signers": [business_signer],
            },
        )
        return tx_sig

    async def swap(
        self,
        pool: Pubkey,
        user_source_ata: Pubkey,
        user_dest_ata: Pubkey,
        amount_in: int,
        min_amount_out: int,
        user_signer: Keypair,
    ) -> str:
        tx_sig = await self.program.rpc["swap"](
            amount_in,
            min_amount_out,
            ctx={
                "accounts": {
                    "pool": pool,
                    "userSource": user_source_ata,
                    "userDest": user_dest_ata,
                    "userAuthority": user_signer.pubkey(),
                    "tokenProgram": TOKEN_PROGRAM_ID,
                },
                "signers": [user_signer],
            },
        )
        return tx_sig

=== services/voucher.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from uuid import UUID
from typing import List
from app.models import VoucherNFT

class VoucherService:
    async def user_vouchers(self, db: AsyncSession, user_id: UUID) -> List[VoucherNFT]:
        stmt = select(VoucherNFT).where(VoucherNFT.user_id == user_id)
        res = await db.execute(stmt)
        return list(res.scalars())

voucher_service = VoucherService()
=== services/promotion_campaign.py ===
# app/services/promotion_campaign.py
from app.crud.base import CRUDBase
from app.services.base import BaseService
from app.models.promotion import PromotionCampaign
from app.schemas.promotion import PromotionCreate, PromotionUpdate

crud_promo = CRUDBase[PromotionCampaign, PromotionCreate, PromotionUpdate](
    PromotionCampaign
)


class PromotionCampaignService(
    BaseService[PromotionCampaign, PromotionCreate, PromotionUpdate]
):
    pass


promotion_campaign_service = PromotionCampaignService(crud_promo)

=== services/tx_history.py ===
from typing import List
from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models.transactions import PointTx, SwapTx

class TxHistoryService:
    async def list_user(
        self, db: AsyncSession, user_id: UUID, *, limit: int = 50
    ) -> List[dict]:
        stmt = select(PointTx).join(PointTx.wallet).where(PointTx.wallet.has(user_id=user_id))
        stmt = stmt.order_by(PointTx.created_at.desc()).limit(limit)
        p_txs = (await db.execute(stmt)).scalars()

        stmt2 = select(SwapTx).where(SwapTx.user_id == user_id).order_by(SwapTx.created_at.desc()).limit(limit)
        s_txs = (await db.execute(stmt2)).scalars()

        rows = [
            {"type": "point", **pt.__dict__} for pt in p_txs
        ] + [
            {"type": "swap", **st.__dict__} for st in s_txs
        ]
        rows.sort(key=lambda r: r["created_at"], reverse=True)
        return rows

tx_history_service = TxHistoryService()

=== services/pool.py ===
import base58
from decimal import Decimal, ROUND_DOWN
from sqlalchemy.ext.asyncio import AsyncSession
from solders.keypair import Keypair
from app.services.exchange_client import ExchangeClient
from app.models.token import Token
from app.models.token_pool import TokenPool
from app.core.settings import settings


class PoolService:
    def __init__(self, db: AsyncSession, anchor: ExchangeClient):
        """
        db: AsyncSession
        anchor: ExchangeClient
        """
        self.db, self.anchor = db, anchor

    async def bootstrap_pool(self, token: Token, percent: Decimal = Decimal("0.25")):
        initial_supply = 1_000_000 * token.base_units

        # 1. calc volumes
        deposit_token = int(initial_supply * percent)

        loyl_dec = (Decimal(deposit_token) * token.rate_loyl).quantize(
            Decimal("1"), rounding=ROUND_DOWN
        )
        deposit_loyl = int(loyl_dec)
        business_kp = Keypair.from_bytes(base58.b58decode(token.business.owner_privkey))

        # deposit_loyl = int(Decimal(deposit_token) * token.rate_loyl)
        # business_kp = Keypair.from_base58_string(token.business.owner_privkey)

        # 2. on-chain transaction (Anchor)
        tx_sig = await self.anchor.init_pool(
            loyalty_mint=token.mint,
            deposit_token=deposit_token,
            deposit_loyl=deposit_loyl,
            business_signer=business_kp,
        )

        # 3. save to db
        pool = TokenPool(
            token_id=token.id,
            provider="platform",
            balance_token=deposit_token,
            balance_loyl=deposit_loyl,
            init_tx=tx_sig,
        )
        self.db.add(pool)
        await self.db.flush()  # ← id needs for Celery-task for confirmation

        return pool

=== services/swap_exec.py ===
import asyncio
from base64 import b64encode, b64decode
from solders.pubkey import Pubkey as PublicKey
from solders.transaction import Transaction
from solders.signature import Signature
from solana.rpc.types import TxOpts
from solana.rpc.commitment import Confirmed
from spl.token.instructions import get_associated_token_address
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from app.core.settings import settings
from app.services.privy_client import PrivyClient
from app.models.transactions import SwapTx
from app.models.token import Token
from app.models.wallet import Wallet
from app.db.session import AsyncSessionLocal
from app.services.exchange_client import ExchangeClient
from spl.token.constants import TOKEN_2022_PROGRAM_ID


async def _perform_swap(swap_tx_id: str):
    # 1) load swap_tx, from_token, wallet and to_token in one session
    async with AsyncSessionLocal() as session:  # type: AsyncSession
        result = await session.execute(
            select(SwapTx, Token, Wallet)
            .join(Token, Token.id == SwapTx.from_token_id)
            .join(Wallet, Wallet.user_id == SwapTx.user_id)
            .where(SwapTx.id == swap_tx_id)
        )
        swap_tx, from_token, wallet = result.first()
        to_token = await session.get(Token, swap_tx.to_token_id)

    user_pubkey = PublicKey(wallet.pubkey)
    from_mint = PublicKey(from_token.mint)
    to_mint = PublicKey(to_token.mint)

    # 2) initialize Anchor client once
    anchor = ExchangeClient(
        rpc_url=settings.SOLANA_RPC_URL,
        payer_keypair=settings.treasury_kp,
        program_id=settings.exchange_program_pk,
        idl_path=settings.root / "anchor/target/idl/exchange.json",
    )
    program = anchor.program
    client = program.provider.connection

    # 3) derive pool PDA
    pool_pda, _ = PublicKey.find_program_address(
        [b"pool", bytes(from_mint)], program.program_id
    )

    # 4) build transaction
    tx = Transaction()
    tx.add(
        program.instruction.swap(
            swap_tx.from_amount,
            swap_tx.to_amount,
            ctx={
                "accounts": {
                    "pool": pool_pda,
                    "userSource": get_associated_token_address(from_mint, user_pubkey),
                    "userDest": get_associated_token_address(to_mint, user_pubkey),
                    "userAuthority": user_pubkey,
                    "tokenProgram": TOKEN_2022_PROGRAM_ID,
                }
            },
        )
    )
    tx.fee_payer = user_pubkey

    # set recent blockhash
    latest = await client.get_latest_blockhash()
    tx.recent_blockhash = latest.value.blockhash

    # 5) sign via Privy and embed signature
    raw_msg = bytes(tx.message)
    msg_b64 = b64encode(raw_msg).decode("utf-8")
    privy = PrivyClient(settings.PRIVY_APP_ID, settings.PRIVY_API_KEY)
    sig_bytes = b64decode(await privy.sign_transaction(wallet.pubkey, msg_b64))
    sig = Signature.from_bytes(sig_bytes)

    # replace placeholder signature for userAuthority
    sigs = list(tx.signatures)  # signatures → tuple
    if len(sigs) < len(tx.message.account_keys):
        # pad with default sigs if anchor didn't pre-fill (edge-case)
        sigs += [Signature.default()] * (len(tx.message.account_keys) - len(sigs))
    idx = tx.message.account_keys.index(user_pubkey)
    sigs[idx] = sig
    tx = tx.replace_signatures(sigs)

    # 6) send signed transaction
    resp = await client.send_raw_transaction(
        bytes(tx),
        opts=TxOpts(skip_preflight=False, preflight_commitment=Confirmed),
    )
    tx_sig = resp.value

    # 7) store sol_sig to DB
    async with AsyncSessionLocal() as session:
        rec = await session.get(SwapTx, swap_tx_id)
        rec.sol_sig = tx_sig
        await session.commit()

    # optional: free RPC resources
    await client.close()


def perform_swap(swap_tx_id: str):
    """Sync wrapper for Celery task."""
    asyncio.run(_perform_swap(swap_tx_id))

=== services/balance.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.services.base import BaseService
from app.crud.base import CRUDBase
from app.models.balance import Balance
from app.schemas.balance import BalanceCreate, BalanceUpdate

crud_balance = CRUDBase[Balance, BalanceCreate, BalanceUpdate](Balance)


class BalanceService(BaseService[Balance, BalanceCreate, BalanceUpdate]):
    async def get_balance(self, db: AsyncSession, wallet, token) -> int:
        q = select(Balance).where(
            Balance.wallet_id == wallet.id, Balance.token_id == token.id
        )
        res = await db.execute(q)
        bal = res.scalar_one_or_none()
        return bal.amount if bal else 0

    async def adjust_balance(
        self, db: AsyncSession, wallet, token, delta: int
    ) -> Balance:
        q = select(Balance).where(
            Balance.wallet_id == wallet.id, Balance.token_id == token.id
        )
        res = await db.execute(q)
        bal = res.scalar_one_or_none()
        if bal is None:
            bal = Balance(wallet_id=wallet.id, token_id=token.id, amount=0)
            db.add(bal)
        bal.amount += delta
        await db.flush()
        return bal


balance_service = BalanceService(crud_balance)

=== services/base.py ===
from uuid import UUID
from typing import Generic, TypeVar
from pydantic import BaseModel
from app.crud.base import CRUDBase
from sqlalchemy.ext.asyncio import AsyncSession

M = TypeVar("M")
C = TypeVar("C", bound=BaseModel)
U = TypeVar("U", bound=BaseModel)


class BaseService(Generic[M, C, U]):
    def __init__(self, crud: CRUDBase[M, C, U]):
        self.crud = crud

    async def create(self, db: AsyncSession, payload: C) -> M:
        return await self.crud.create(db, payload)

    async def read(self, db: AsyncSession, id: str | UUID) -> M | None:
        return await self.crud.read(db, id)

    async def read_many(
        self, db: AsyncSession, *, start: int = 0, limit: int = 10, filters=None
    ) -> list[M]:
        return await self.crud.read_many(db, start=start, limit=limit, filters=filters)

    async def update(self, db: AsyncSession, db_obj: M, payload: U) -> M:
        return await self.crud.update(db, db_obj, payload)

    async def delete(self, db: AsyncSession, id: str | UUID) -> None:
        await self.crud.delete(db, id)

=== services/loyalty.py ===
import logging
import base58
from decimal import Decimal, ROUND_DOWN
from typing import Dict
from solders.keypair import Keypair
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from app.models import Business, Wallet, PromotionCampaign, TxType
from app.services.balance import balance_service
from app.services.point_tx import point_tx_service
from app.schemas.point_tx import PointTxCreate
from app.tasks.transfer import transfer_earn_task, transfer_redeem_task

logger = logging.getLogger(__name__)


class InsufficientPointsError(Exception):
    """Raised when wallet has insufficient loyalty points for redemption."""


class LoyaltyService:
    """
    High-level domain service for earning / redeeming loyalty points.
    """

    def __init__(self, db: AsyncSession):
        """
        :param db: SQLAlchemy AsyncSession, transaction is managed by caller.
        """
        self.db = db

    async def earn_points(
        self,
        *,
        business: Business,
        wallet: Wallet,
        purchase_amount: Decimal,
    ) -> PointTxCreate:
        """
        Earn loyalty points for a purchase.

        1) Compute 'points' = floor(purchase_amount / rate_loyl) * base_units.
        2) Enqueue on-chain transfer (business → user).
        3) Update off-chain balance.
        4) Record PointTx in DB.

        :raises ValueError: if business.loyalty_token missing or invalid amounts.
        :return: PointTxCreate instance (with DB fields populated).
        """
        # 1) Validate
        token = business.loyalty_token
        if token is None:
            raise ValueError("Business has no loyalty token configured")

        if purchase_amount <= 0:
            raise ValueError("purchase_amount must be positive")

        # 2) Compute points in base units
        raw_units = (purchase_amount / business.rate_loyl).quantize(
            Decimal("1"), rounding=ROUND_DOWN
        )
        points = int(raw_units) * token.base_units
        if points <= 0:
            raise ValueError("purchase_amount too small to earn any points")

        # 3) Enqueue on-chain transfer
        transfer_earn_task.delay(
            business_kp_b58=business.owner_privkey,
            mint=token.mint,
            user_pubkey=wallet.pubkey,
            amount=points,
        )
        logger.info("Enqueued earn_points: biz=%s user=%s pts=%d",
                    business.id, wallet.user_id, points)

        # 4) Update off-chain balance
        bal = await balance_service.adjust_balance(self.db, wallet, token, points)
        # flush so that balance exists in same transaction
        await self.db.flush()

        # 5) Persist PointTx record
        pt_schema = PointTxCreate(
            wallet_id=wallet.id,
            tx_type=TxType.EARN,
            token_id=token.id,
            amount=points,
            fee_bps=0,
            sol_sig=None,
        )
        pt = await point_tx_service.create(self.db, pt_schema)
        logger.debug("Created PointTx EARN id=%s", pt.id)

        return pt

    async def redeem_points(
        self,
        *,
        campaign: PromotionCampaign,
        wallet: Wallet,
        purchase_amount: Decimal,
    ) -> Dict[str, any]:
        """
        Redeem loyalty points against a promotion campaign.

        1) Check wallet balance >= campaign.price_points.
        2) Enqueue on-chain transfer (user → business).
        3) Update off-chain balance.
        4) Record PointTx(REDEEM).
        5) Compute discount & final amount.

        :raises InsufficientPointsError: if balance < price_points.
        :raises ValueError: if campaign invalid or purchase_amount <= 0.
        :return: dict with keys: point_tx, discount, final_amount.
        """
        # 1) Validate campaign & amounts
        biz = campaign.business
        token = biz.loyalty_token
        if token is None:
            raise ValueError("Business has no loyalty token configured")
        if purchase_amount <= 0:
            raise ValueError("purchase_amount must be positive")

        # 2) Check off-chain balance
        balance = await balance_service.get_balance(self.db, wallet, token)
        if balance < campaign.price_points:
            raise InsufficientPointsError(
                f"Balance {balance} < required {campaign.price_points}"
            )

        # 3) Prepare business pubkey for on-chain transfer
        biz_kp = Keypair.from_bytes(base58.b58decode(biz.owner_privkey))
        biz_pubkey = str(biz_kp.pubkey())

        # 4) Enqueue on-chain transfer
        transfer_redeem_task.delay(
            user_pubkey=wallet.pubkey,
            mint=token.mint,
            business_pubkey=biz_pubkey,
            amount=campaign.price_points,
        )
        logger.info("Enqueued redeem_points: biz=%s user=%s pts=%d",
                    biz.id, wallet.user_id, campaign.price_points)

        # 5) Update off-chain balance
        await balance_service.adjust_balance(self.db, wallet, token, -campaign.price_points)
        await self.db.flush()

        # 6) Persist PointTx(REDEEM)
        pt_schema = PointTxCreate(
            wallet_id=wallet.id,
            tx_type=TxType.REDEEM,
            token_id=token.id,
            amount=campaign.price_points,
            fee_bps=0,
            sol_sig=None,
        )
        pt = await point_tx_service.create(self.db, pt_schema)
        logger.debug("Created PointTx REDEEM id=%s", pt.id)

        # 7) Compute discount & final amount
        discount = (purchase_amount * Decimal(campaign.discount_pct)) / Decimal(100)
        final_amount = (purchase_amount - discount).quantize(Decimal("0.01"))

        return {
            "point_tx": pt,
            "discount": discount,
            "final_amount": final_amount,
        }

=== services/wallet.py ===
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.crud.base import CRUDBase
from app.models.wallet import Wallet
from app.schemas.wallet import WalletCreate, WalletUpdate
from app.services.base import BaseService

crud_wallet = CRUDBase[Wallet, WalletCreate, WalletUpdate](Wallet)


class WalletService(BaseService[Wallet, WalletCreate, WalletUpdate]):
    async def add_if_missing(self, db: AsyncSession, user, pubkey: str) -> Wallet:
        # 1) try to find
        q = select(Wallet).where(Wallet.user_id == user.id, Wallet.pubkey == pubkey)
        res = await db.execute(q)
        wallet = res.scalar_one_or_none()
        if wallet:
            return wallet
        # 2) else create
        payload = WalletCreate(user_id=user.id, pubkey=pubkey)
        return await self.create(db, payload)


wallet_service = WalletService(crud_wallet)

=== ws/ws_redis.py ===
"""Singleton async Redis connection using redis>=4.0."""
from __future__ import annotations
from functools import lru_cache
from redis.asyncio import Redis as _Redis
from app.core.settings import settings


@lru_cache(maxsize=1)
def redis_conn() -> _Redis:
    return _Redis.from_url(settings.CELERY_BROKER, decode_responses=True)

=== ws/manager.py ===
from __future__ import annotations
import json, asyncio
from typing import Dict, Set
from fastapi import WebSocket
from app.ws.ws_redis import redis_conn


class WSManager:
    """
    Keeps in-memory mapping swap_id → set[WebSocket],
    relays Redis pubsub messages to connected clients.
    """

    _instance: "WSManager" | None = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._init()
        return cls._instance

    # --------------------------------------------------------------------- #
    def _init(self) -> None:
        self._clients: Dict[str, Set[WebSocket]] = {}
        self._redis = redis_conn()
        self._loop_task = asyncio.create_task(self._redis_listener())

    async def _redis_listener(self) -> None:
        """
        Background task: subscribes to channel "swap:*", relays payloads.
        Payload format: {"swap_id": <uuid>, "event": "success|failed|pending"}
        """
        pubsub = self._redis.pubsub()
        await pubsub.psubscribe("swap:*")

        async for msg in pubsub.listen():
            if msg["type"] != "pmessage":
                continue
            payload = json.loads(msg["data"])
            swap_id = payload["swap_id"]
            clients = list(self._clients.get(swap_id, set()))
            for ws in clients:
                try:
                    await ws.send_json(payload)
                except Exception:  # noqa: BLE001
                    await self.disconnect(swap_id, ws)

    # ------------------------------------------------------------------ API
    async def connect(self, swap_id: str, ws: WebSocket) -> None:
        await ws.accept()
        self._clients.setdefault(swap_id, set()).add(ws)

    async def disconnect(self, swap_id: str, ws: WebSocket) -> None:
        conns = self._clients.get(swap_id)
        if conns and ws in conns:
            conns.remove(ws)
            await ws.close()
        if conns and not conns:
            self._clients.pop(swap_id, None)
